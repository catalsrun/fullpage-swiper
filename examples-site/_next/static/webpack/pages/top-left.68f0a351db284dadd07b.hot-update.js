webpackHotUpdate_N_E("pages/top-left",{

/***/ "../src/index.js":
/*!***********************!*\
  !*** ../src/index.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FullpageSwiper; });\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ \"../node_modules/hammerjs/hammer.js\");\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap */ \"../node_modules/gsap/index.js\");\n\n\n\nclass FullpageSwiper {\n  static getViewport() {\n    return {\n      // webview issue - undefined : window.innerWidth, window.innerHeight\n      clientWidth: window.innerWidth || document.documentElement.clientWidth,\n      clientHeight: window.innerHeight || document.documentElement.clientHeight\n    };\n  }\n  static getRandomColor() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n  constructor(selector, options = {}) {\n    this.containerRef = document.querySelector(selector);\n    this.containerType = this.containerRef.getAttribute('data-stack-type');\n    if (!(this.containerRef && this.containerType)) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'fullpage-swiper initialization error, check selector',\n        selector\n      );\n      return;\n    }\n    if (!hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a || !gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '\"Hammer\" and \"gsap\" peerDependencies are required'\n      );\n      return;\n    }\n    this.dep = { Hammer: (hammerjs__WEBPACK_IMPORTED_MODULE_0___default()), gsap: gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"] };\n    this.containerAxis =\n      this.containerType === 'top' || this.containerType === 'y'\n        ? 'vertical'\n        : 'horizontal';\n\n    this.options = Object.assign({ debug: false }, options);\n\n    this.parents = [];\n    this.stacks = [];\n    this.hammers = [];\n\n    this.currentIdx = 0;\n    this.eventAxis = '';\n    this.eventDirection = '';\n    this.dragging = false;\n    this.draggingRef = null;\n\n    this.viewport = FullpageSwiper.getViewport();\n\n    this.setParents();\n    this.setStacks();\n    this.setCommonLayout();\n    this.setLayout();\n\n    // const config = this.options.parentsConfig[parent.id] || {}\n    this._addEvents();\n\n    this.options.debug && this.debug();\n  }\n  removeListeners() {}\n  _blockEvent(eventAxis) {\n    // 최초 이벤트 요청일 경우 블록 X\n    if (this.eventAxis === '') {\n      this.eventAxis = eventAxis;\n      return false;\n    }\n    // 1.드래깅중이 아닐 경우 이벤트 블록\n    // 2. 진행중인 드래깅이 존재하는 경우, 요청 이벤트 타입이 동일하지 않으면 블록\n    if (!this.isDragging || this.eventAxis !== eventAxis) {\n      // console.log('blocked event', eventType);\n      return true;\n    }\n\n    // 동일한 axis의 드래깅중인 경우 업데이트\n    this.eventAxis = eventAxis;\n  }\n  _resetDrag() {\n    this.dragging = false;\n    this.eventAxis = '';\n    this.eventDirection = '';\n    this.draggingRef = null;\n    this.stackMoveFromTo = {};\n  }\n  _getDraggingInfo(eventTarget) {\n    console.log('this.eventDirection', this.eventDirection, eventTarget);\n    if (eventTarget) {\n      // obj { from, to, draggable }\n      let obj = eventTarget.canMoveToSibling[this.eventDirection];\n      if (!obj) {\n        obj = eventTarget.canMoveToParent[this.eventDirection];\n      }\n      return obj; \n    }\n    return {};\n  }\n  _panstart(e) {\n    this.isDragging = true;\n    this.eventTarget = this.stacks.find(\n      stack => stack.node === e.currentTarget\n    );\n    if (!this.eventTarget) {\n      this.isDragging = false;\n      return;\n    }\n    this.options.dragStart(this);\n  }\n  _panleft(e) {\n    const eventAxis = 'horizontal';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'left';\n\n    this.eventDirection = 'left';\n    // console.log('START:', eventType.direction);\n    \n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _panright(e) {\n    const eventAxis = 'horizontal';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'right';\n\n    this.eventDirection = 'right';\n    // console.log('START:', eventType.direction);\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _pandown(e) {\n    const eventAxis = 'vertical';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'down';\n\n    this.eventDirection = 'down';\n    // console.log('START:', eventType.direction, this.draggingRef);\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  \n  _panup(e) {\n    const eventAxis = 'vertical';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'up';\n    this.eventDirection = 'up';\n    // console.log('from to', data.from, data.to);\n\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _endCallback() {\n    const { stackMoveFromTo } = this;\n    console.log('_endCallback stackMoveFromTo', stackMoveFromTo);\n    if (stackMoveFromTo.from !== stackMoveFromTo.to) {\n      if (stackMoveFromTo.toParent) {\n        stackMoveFromTo.toParent.lastSeenIndex = stackMoveFromTo.to;\n      }\n    }\n    this.currentIdx = stackMoveFromTo.to;\n    this.options.dragEnd(this);\n    this._resetDrag();\n  }\n  _panend() {\n    // console.log('START: panend', this.eventType, !!this.draggingRef);\n    if (this.draggingRef) {\n      // gsap 콜백내에서 this.draggingRef 의 값이 null 이 될 가능성이 존재하므로\n      // 드래깅되는 객체의 주소지를 변수로 저장해서 사용\n      const draggingRef = this.draggingRef;\n      const direction = this.eventDirection;\n      const { type } = draggingRef;\n      const { clientHeight, clientWidth } = this.viewport;\n      const t = this.dep.gsap.timeline();\n\n      if (type === 'top') {\n        if (direction === 'up') {\n          if (draggingRef.positions.top !== 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { top: -clientHeight }).add(() => {\n            draggingRef.positions.top = -clientHeight;\n            this._endCallback();\n          });\n        }\n        if (direction === 'down') {\n          if (draggingRef.positions.top === 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { top: 0 }).add(() => {\n            draggingRef.positions.top = 0;\n            this._endCallback();\n          });\n        }\n      }\n      if (type === 'left') {\n        if (direction === 'left') {\n          if (draggingRef.positions.left !== 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n\n          t.to(draggingRef.node, { left: -clientWidth }).add(() => {\n            draggingRef.positions.left = -clientWidth;\n            this._endCallback();\n          });\n        }\n        if (direction === 'right') {\n          if (draggingRef.positions.left === 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { left: 0 }).add(() => {\n            draggingRef.positions.left = 0;\n            this._endCallback();\n          });\n        }\n      }\n\n      if (type === 'y') {\n        const gap = draggingRef.positions.y - this.snapshotPositions.y;\n        const y = draggingRef.positions.y;\n        if (direction === 'up') {\n          const canNext = this.snapshotPositions.y < y;\n          let move = y;\n          if (canNext) {\n            move = y - clientHeight;\n            const max = -clientHeight * (draggingRef.children.length - 1);\n            if (move < max) move = max;\n          }\n\n          if (gap < 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n\n          t.to(draggingRef.node, { y: move }).add(() => {\n            draggingRef.positions.y = move;\n            this._endCallback();\n          });\n        }\n        if (direction === 'down') {\n          const canNext = this.snapshotPositions.y > y;\n          let move = y;\n          if (canNext) {\n            move = y + clientHeight;\n            if (move >= 0) move = 0;\n          }\n          if (gap > 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { y: move }).add(() => {\n            draggingRef.positions.y = move;\n            this._endCallback();\n          });\n        }\n      }\n\n      if (type === 'x') {\n        const x = draggingRef.positions.x;\n        if (direction === 'left') {\n          const canNext = this.snapshotPositions.x < x;\n\n          let move = x;\n          if (canNext) {\n            move = x - clientWidth;\n            const max = -clientWidth * (draggingRef.children.length - 1);\n            if (move < max) move = max;\n          } else {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { x: move }).add(() => {\n            draggingRef.positions.x = move;\n            this._endCallback();\n          });\n        }\n        if (direction === 'right') {\n          const canNext = this.snapshotPositions.x > x;\n          let move = x;\n          if (canNext) {\n            move = x + clientWidth;\n            if (move >= 0) move = 0;\n          } else {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { x: move }).add(() => {\n            draggingRef.positions.x = move;\n            this._endCallback();\n          });\n        }\n      }\n    } else {\n      this._resetDrag();\n    }\n  }\n  // this.distance 값에 따라 드래그 가동범위 셋팅 가능하도록\n  // Math.abs(e.deltaY), Math.abs(e.deltaX)\n  _dragging(e) {\n    const target = this.draggingRef;\n    const { type } = target;\n    const { clientHeight, clientWidth } = this.viewport;\n\n    this.snapshotPositions = {\n      top: 0,\n      left: 0,\n      x: 0,\n      y: 0\n    };\n    const positions = this.snapshotPositions;\n    let posY, posX;\n\n    \n    if (this.isDifferentEvent) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (type === 'y') {\n      posY = e.deltaY + target.positions.y;\n\n      if (posY >= 0) {\n        target.positions.y = 0;\n        target.node.style.transform = 'translate3d(0px, 0px, 0px)';\n        console.log('this.isDifferentEvent2', this.isDifferentEvent);\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      } else {\n        // 경계면 이동시 버그?\n        const max = -clientHeight * (target.children.length - 1);\n        if (posY <= max) {\n          target.positions.y = max;\n          target.node.style.transform = `translate3d(0px, ${max}px, 0px)`;\n          console.log('this.isDifferentEvent1', this.isDifferentEvent);\n          // change dragging target\n          // this.draggingInfo = this._getDraggingInfo(stackView);\n          // this.draggingRef = this.draggingInfo.draggable;\n          return;\n        }\n        console.log('this.isDifferentEvent3', this.isDifferentEvent);\n      }\n\n      // 실제 그려짐\n      positions.y = posY;\n      this.dep.gsap.set(target.node, { y: posY });\n    }\n    if (type === 'x') {\n      posX = e.deltaX + target.positions.x;\n      if (posX >= 0) {\n        target.positions.x = 0;\n        target.node.style.transform = 'translate3d(0px, 0px, 0px)';\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      const max = -clientWidth * (target.children.length - 1);\n      if (posX <= max) {\n        target.positions.x = max;\n        target.node.style.transform = `translate3d(${max}px, 0px, 0px)`;\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      positions.x = posX;\n      this.dep.gsap.set(target.node, { x: posX });\n    }\n    if (type === 'top') {\n      posY = e.deltaY + target.positions.top;\n      if (posY >= 0) {\n        target.positions.top = 0;\n        target.node.style.top = 0 + 'px';\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      if (posY <= -clientHeight) {\n        target.positions.top = -clientHeight;\n        target.node.style.top = -clientHeight + 'px';\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n\n      positions.top = posY;\n      this.dep.gsap.set(target.node, { top: posY });\n    }\n\n    if (type === 'left') {\n      posX = target.positions.left + e.deltaX;\n      if (posX >= 0) {\n        target.positions.left = 0;\n        target.node.style.left = 0 + 'px';\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      if (posX <= -clientWidth) {\n        target.positions.left = -clientWidth;\n        target.node.style.left = -clientWidth + 'px';\n        // change dragging target\n        // this.draggingInfo = this._getDraggingInfo(stackView);\n        // this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n\n      positions.left = posX;\n      this.dep.gsap.set(target.node, { left: posX });\n    }\n\n    // console.log('_dragging', type, this.eventDirection, posY, this.eventTarget, this.draggingInfo);\n\n    this.stackMoveFromTo = this._getStackMoveFromTo();\n    // console.log('dragging stackMoveFromTo', this.stackMoveFromTo);\n\n    this.options.dragMove(this);\n    // top 의 경우시\n    // siblingIndex 0, posY 0, -1, -2, ... -> end Event 시 -667\n    // siblingIndex 0 값은 점점 hide, sliblingindex 1값은 하단 부터 점점 노출\n  }\n  _getStackMoveFromTo() {\n    const { from, to, changeableTo } = this.draggingInfo;\n    const result = {\n      from,\n    };\n    if (to !== undefined) {\n      const toParent = this.stacks[to].innerParent;\n      result.to = to;\n      result.toParent = toParent;\n    } else if (changeableTo !== undefined) {\n      const toParent = this.stacks[changeableTo].innerParent;\n      result.to = toParent.lastSeenIndex ? toParent.lastSeenIndex : changeableTo;\n      result.toParent = toParent;\n    }\n    // console.log('from', from, to, changeableTo, result);\n\n    return result;\n  }\n\n  _addEvents() {\n    // mobile 일 경우\n    // touchstart, touchmove, touchend 3가지 등록\n\n    // pc 일 경우\n    // DOMMouseScroll mousewheel\n    // mousedown, mousemove, mouseup\n    // keydown\n\n    // resizeComplete 시 currentIdx 로 이동\n\n    const mc = new this.dep.Hammer(this.containerRef);\n    // save mc instance for remove event listeners - mc.off();\n    this.hammers.push(mc);\n    mc.add(\n      new this.dep.Hammer.Pan({\n        direction: this.dep.Hammer.DIRECTION_ALL,\n        threshold: this.options.threshold\n      })\n    );\n    // console.log(2);\n\n    // Hammer pan event issue : not support event.currentTarget\n    this.stacks.forEach(({ node }) => {\n      node.addEventListener('touchstart', this._panstart.bind(this), false);\n    });\n\n    mc.on('panend', this._panend.bind(this));\n    mc.on('panleft', this._panleft.bind(this));\n    mc.on('panright', this._panright.bind(this));\n    mc.on('pandown', this._pandown.bind(this));\n    mc.on('panup', this._panup.bind(this));\n  }\n  setCommonLayout() {\n    // Block x,y scrolling\n    // Required in Samsung Internet browser\n    document.documentElement.style.overflow = 'hidden';\n    document.documentElement.style.height = '100%';\n    document.documentElement.style.width = '100%';\n\n    document.body.style.overflow = 'hidden';\n    document.body.style.height = '100%';\n    document.body.style.width = '100%';\n  }\n  setLayout() {\n    this.viewport = FullpageSwiper.getViewport();\n    // 부모 컨테이너 layout\n    this.parents.forEach(parent => {\n      // data-stack-type 에 따라 layout setting\n      // x, y, top, left\n      switch (parent.type) {\n      case 'x':\n        this._layoutX(parent);\n        return;\n      case 'y':\n        this._layoutY(parent);\n        return;\n      case 'top':\n      case 'left':\n        this._layoutFixed(parent);\n        return;\n      }\n    });\n  }\n  _layoutX(parent) {\n    const { clientHeight, clientWidth } = this.viewport;\n    const { node, children } = parent;\n    node.x = node.y = 0;\n    node.style.display = 'flex';\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.width = clientWidth * children.length + 'px';\n    node.style.transform = 'translate3d(0px, 0px, 0px)';\n    children.forEach(({ node }) => {\n      node.style.width = clientWidth + 'px';\n      node.style.height = clientHeight + 'px';\n    });\n  }\n  _layoutY(parent) {\n    const { clientHeight } = this.viewport;\n    const { node, children } = parent;\n    node.x = node.y = 0;\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.height = clientHeight * children.length + 'px';\n    node.style.transform = 'translate3d(0px, 0px, 0px)';\n    children.forEach(({ node }) => {\n      node.style.height = clientHeight + 'px';\n    });\n  }\n  _layoutFixed(parent) {\n    const { clientHeight, clientWidth } = this.viewport;\n    const { node, children } = parent;\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.height = clientHeight + 'px';\n    node.style.width = clientWidth + 'px';\n\n    children.forEach(({ node }, idx, arr) => {\n      node.style.position = 'absolute';\n      node.style.top = 0;\n      node.style.left = 0;\n      node.style.height = clientHeight + 'px';\n      node.style.width = clientWidth + 'px';\n      node.style.zIndex = (arr.length - idx) * 10;\n    });\n  }\n  setParents() {\n    this.parents = Array.from(\n      document.querySelectorAll('[data-stack-type]')\n    ).map(parent => {\n      const type = parent.getAttribute('data-stack-type');\n      const axis =\n        type === 'top' || type === 'y' ? 'vertical' : 'horizontal';\n\n      let children = [];\n      // if parent is root parent\n      if (parent === this.containerRef) {\n        children = Array\n          .from(parent.children)\n          .filter(el => typeof el.getAttribute('data-stack') === 'string');\n      } else {\n        children = Array\n          .from(parent.querySelectorAll('[data-stack]'))\n          .filter(el => typeof el.getAttribute('data-stack') === 'string');\n      }\n\n      return {\n        type,\n        axis,\n        node: parent,\n        isRoot: parent === this.containerRef,\n        children,\n        positions: {\n          x: 0,\n          y: 0,\n          top: 0,\n          left: 0\n        }\n      };\n    });\n  }\n  setStacks() {\n    // filter function - only [data-stack] element\n    const filter = node => {\n      const isStack =\n        node && typeof node.getAttribute('data-stack') === 'string';\n      \n      const result = isStack\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP;\n     \n      return result;\n    };\n    \n    const walker = document.createTreeWalker(\n      this.containerRef,\n      NodeFilter.SHOW_ELEMENT,\n      filter,\n      false\n    );\n\n    // node is [data-stack] element\n    let node = walker.firstChild();\n    let idx = 0;\n    while (node !== null) {\n      let parentNode = node.parentNode;\n      let type;\n      while (parentNode !== null) {\n        type = parentNode.getAttribute('data-stack-type');\n        if (type) {\n          break;\n        } else {\n          parentNode = parentNode.parentNode;\n        }\n      }\n\n      const isVertical = type === 'top' || type === 'y';\n      const direction = isVertical ? 'vertical' : 'horizontal';\n      const innerParentIndex = this.parents.findIndex(p => p.node === parentNode);\n      const innerParent = this.parents[innerParentIndex];\n\n      if (innerParent.node === this.containerRef) {\n        innerParent.outerParent = null;\n      } else {\n        // data-stack (this is outerParent) > data-stack-type (this is innerParent)\n        const outerParent = this.parents[0].children.find(outer => {\n          return outer.node.querySelector('[data-stack-type]') === parentNode;\n        });\n        if (outerParent) {\n          innerParent.outerParent = outerParent;\n        }\n      }\n\n      const siblingIndex = innerParent.children.findIndex(el => el === node);\n      const stackView = {\n        type,\n        axis: direction,\n        node, // for e.target\n        innerParent,\n        innerParentIndex,\n        isRootLevelStack: innerParent.isRoot,\n        children: innerParent.children,\n        isFirstNode: siblingIndex === 0,\n        isLastNode: siblingIndex === innerParent.children.length - 1,\n        positions: {\n          x: 0,\n          y: 0,\n          top: 0,\n          left: 0\n        },\n        siblingIndex,\n      };\n      innerParent.children[siblingIndex] = stackView;\n\n      const child = walker.firstChild();\n      if (child) {\n        node = child;\n      } else {\n        const next = walker.nextSibling();\n        if (next) {\n          node = next;\n        } else {\n          if (walker.parentNode()) {\n            node = walker.nextSibling();\n          } else {\n            node = null;\n          }\n        }\n      }\n      if (!stackView.isRootLevelStack) {\n        stackView.stackIndex = idx++;\n        stackView.canMoveToSibling = this._canMoveToSibling(stackView);\n        this.stacks.push(stackView);\n      }\n    }\n\n    this.stacks.forEach((item) => {\n      item.canMoveToParent = this._canMoveToParent(item);\n    });\n  }\n  _canMoveToParent(stack) {\n    const axis = this.parents[0].axis;\n    const type = this.parents[0].type;\n\n    const { canMoveToSibling, innerParent, innerParentIndex } = stack;\n    const { outerParent } = innerParent;\n    const result = {\n      up: !canMoveToSibling.up && axis === 'vertical' && !outerParent.isLastNode,\n      down: !canMoveToSibling.down && axis === 'vertical' && !outerParent.isFirstNode,\n      left: !canMoveToSibling.left && axis === 'horizontal' && !outerParent.isLastNode,\n      right: !canMoveToSibling.right && axis === 'horizontal' && !outerParent.isFirstNode\n    };\n\n    if (result.up) {\n      result.up = { \n        from: stack.stackIndex\n      };\n      if (type === 'y') {\n        result.up.draggable = outerParent.innerParent;\n      }\n      if (type === 'top') {\n        result.up.draggable = outerParent;\n      }\n      const nextParent = this.parents[innerParentIndex + 1];\n      if (nextParent.axis === axis) {\n        result.up.to = nextParent.children[0].stackIndex;\n      } else {\n        result.up.changeableTo = nextParent.children[0].stackIndex;\n        // 도착지가 다른 축인 경우\n        // - vertical -> horizontal\n      }\n    }\n    if (result.left) {\n      result.left = { \n        from: stack.stackIndex\n      };\n      if (type === 'x') {\n        result.left.draggable = outerParent.innerParent;\n      }\n      if (type === 'left') {\n        result.left.draggable = outerParent;\n      }\n      const nextParent = this.parents[innerParentIndex + 1];\n      if (nextParent.axis === axis) {\n        result.left.to = nextParent.children[0].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - horizontal -> vertical\n        result.left.changeableTo = nextParent.children[0].stackIndex;\n      }\n    }\n\n    if (result.down) {\n      result.down = { \n        from: stack.stackIndex\n      };\n      if (type === 'y') {\n        result.down.draggable = outerParent.innerParent;\n      }\n      const nextParent = this.parents[innerParentIndex - 1];\n      if (type === 'top') {\n        const draggable = nextParent.outerParent;\n        result.down.draggable = draggable;\n      }\n      if (nextParent.axis === axis) {\n        result.down.to = nextParent.children[nextParent.children.length - 1].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - horizontal -> vertical\n        result.down.changeableTo = nextParent.children[nextParent.children.length - 1].stackIndex;\n      }\n    }\n\n    if (result.right) {\n      result.right = { \n        from: stack.stackIndex\n      };\n      if (type === 'x') {\n        result.right.draggable = outerParent.innerParent;\n      }\n      const nextParent = this.parents[innerParentIndex - 1];\n      if (type === 'left') {\n        const draggable = nextParent.outerParent;\n        result.right.draggable = draggable;\n      }\n      if (nextParent.axis === axis) {\n        result.right.to = nextParent.children[nextParent.children.length - 1].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - vertical -> horizontal\n        result.right.changeableTo = nextParent.children[nextParent.children.length - 1].stackIndex;\n      }\n    }\n\n    return result;\n  }\n  _canMoveToSibling(stack) {\n    const axis = stack.innerParent.axis;\n    const type = stack.innerParent.type;\n    const result = {\n      up: axis === 'vertical' && !stack.isLastNode,\n      down: axis === 'vertical' && !stack.isFirstNode,\n      left: axis === 'horizontal' && !stack.isLastNode,\n      right: axis === 'horizontal' && !stack.isFirstNode,\n    };\n    if (result.up) {\n      result.up = { \n        from: stack.stackIndex, to: stack.stackIndex + 1\n      };\n      if (type === 'y') {\n        result.up.draggable = stack.innerParent;\n      }\n      if (type === 'top') {\n        result.up.draggable = stack;\n      }\n    }\n    if (result.left) {\n      result.left = { from: stack.stackIndex, to: stack.stackIndex + 1 };\n      if (type === 'x') {\n        result.left.draggable = stack.innerParent;\n      }\n      if (type === 'left') {\n        result.left.draggable = stack;\n      }\n    }\n\n    if (result.down) {\n      result.down = { from: stack.stackIndex, to: stack.stackIndex - 1 };\n      if (type === 'y') {\n        result.down.draggable = stack.innerParent;\n      }\n      if (type === 'top') {\n        result.down.draggable = this.stacks[stack.stackIndex - 1];\n      }\n    }\n    if (result.right) {\n      result.right = { from: stack.stackIndex, to: stack.stackIndex - 1 };\n      if (type === 'x') {\n        result.right.draggable = stack.innerParent;\n      }\n      if (type === 'left') {\n        result.right.draggable = this.stacks[stack.stackIndex - 1];\n      }\n    }\n    return result;\n  }\n \n  debug() {\n    this.stacks.forEach(el => {\n      const color = FullpageSwiper.getRandomColor();\n      el.node.style.backgroundColor = color;\n    });\n    // eslint-disable-next-line no-console\n    console.log('STACK_PARENTS: ', this.parents);\n    // eslint-disable-next-line no-console\n    console.log('STACK_VIEW: ', this.stacks);\n    window.fps = this;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9pbmRleC5qcz9hMTc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEI7QUFDTjs7QUFFVDtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFNLEtBQUssNENBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLENBQUMseURBQU0sRUFBRSxrREFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsZUFBZTs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLDRCQUE0QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyw0QkFBNEI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxJQUFJO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtEQUFrRDtBQUM3RCxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGFtbWVyIGZyb20gJ2hhbW1lcmpzJztcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdWxscGFnZVN3aXBlciB7XG4gIHN0YXRpYyBnZXRWaWV3cG9ydCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gd2VidmlldyBpc3N1ZSAtIHVuZGVmaW5lZCA6IHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIGNsaWVudFdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRIZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0UmFuZG9tQ29sb3IoKSB7XG4gICAgY29uc3QgbGV0dGVycyA9ICcwMTIzNDU2Nzg5QUJDREVGJztcbiAgICBsZXQgY29sb3IgPSAnIyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGNvbG9yICs9IGxldHRlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNvbnRhaW5lclJlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHRoaXMuY29udGFpbmVyVHlwZSA9IHRoaXMuY29udGFpbmVyUmVmLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGFjay10eXBlJyk7XG4gICAgaWYgKCEodGhpcy5jb250YWluZXJSZWYgJiYgdGhpcy5jb250YWluZXJUeXBlKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdmdWxscGFnZS1zd2lwZXIgaW5pdGlhbGl6YXRpb24gZXJyb3IsIGNoZWNrIHNlbGVjdG9yJyxcbiAgICAgICAgc2VsZWN0b3JcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghSGFtbWVyIHx8ICFnc2FwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1wiSGFtbWVyXCIgYW5kIFwiZ3NhcFwiIHBlZXJEZXBlbmRlbmNpZXMgYXJlIHJlcXVpcmVkJ1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXAgPSB7IEhhbW1lciwgZ3NhcCB9O1xuICAgIHRoaXMuY29udGFpbmVyQXhpcyA9XG4gICAgICB0aGlzLmNvbnRhaW5lclR5cGUgPT09ICd0b3AnIHx8IHRoaXMuY29udGFpbmVyVHlwZSA9PT0gJ3knXG4gICAgICAgID8gJ3ZlcnRpY2FsJ1xuICAgICAgICA6ICdob3Jpem9udGFsJztcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBkZWJ1ZzogZmFsc2UgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmVudHMgPSBbXTtcbiAgICB0aGlzLnN0YWNrcyA9IFtdO1xuICAgIHRoaXMuaGFtbWVycyA9IFtdO1xuXG4gICAgdGhpcy5jdXJyZW50SWR4ID0gMDtcbiAgICB0aGlzLmV2ZW50QXhpcyA9ICcnO1xuICAgIHRoaXMuZXZlbnREaXJlY3Rpb24gPSAnJztcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kcmFnZ2luZ1JlZiA9IG51bGw7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0gRnVsbHBhZ2VTd2lwZXIuZ2V0Vmlld3BvcnQoKTtcblxuICAgIHRoaXMuc2V0UGFyZW50cygpO1xuICAgIHRoaXMuc2V0U3RhY2tzKCk7XG4gICAgdGhpcy5zZXRDb21tb25MYXlvdXQoKTtcbiAgICB0aGlzLnNldExheW91dCgpO1xuXG4gICAgLy8gY29uc3QgY29uZmlnID0gdGhpcy5vcHRpb25zLnBhcmVudHNDb25maWdbcGFyZW50LmlkXSB8fCB7fVxuICAgIHRoaXMuX2FkZEV2ZW50cygpO1xuXG4gICAgdGhpcy5vcHRpb25zLmRlYnVnICYmIHRoaXMuZGVidWcoKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcnMoKSB7fVxuICBfYmxvY2tFdmVudChldmVudEF4aXMpIHtcbiAgICAvLyDstZzstIgg7J2067Kk7Yq4IOyalOyyreydvCDqsr3smrAg67iU66GdIFhcbiAgICBpZiAodGhpcy5ldmVudEF4aXMgPT09ICcnKSB7XG4gICAgICB0aGlzLmV2ZW50QXhpcyA9IGV2ZW50QXhpcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gMS7rk5zrnpjquYXspJHsnbQg7JWE64uQIOqyveyasCDsnbTrsqTtirgg67iU66GdXG4gICAgLy8gMi4g7KeE7ZaJ7KSR7J24IOuTnOuemOq5heydtCDsobTsnqztlZjripQg6rK97JqwLCDsmpTssq0g7J2067Kk7Yq4IO2DgOyeheydtCDrj5nsnbztlZjsp4Ag7JWK7Jy866m0IOu4lOuhnVxuICAgIGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuZXZlbnRBeGlzICE9PSBldmVudEF4aXMpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdibG9ja2VkIGV2ZW50JywgZXZlbnRUeXBlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIOuPmeydvO2VnCBheGlz7J2YIOuTnOuemOq5heykkeyduCDqsr3smrAg7JeF642w7J207Yq4XG4gICAgdGhpcy5ldmVudEF4aXMgPSBldmVudEF4aXM7XG4gIH1cbiAgX3Jlc2V0RHJhZygpIHtcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudEF4aXMgPSAnJztcbiAgICB0aGlzLmV2ZW50RGlyZWN0aW9uID0gJyc7XG4gICAgdGhpcy5kcmFnZ2luZ1JlZiA9IG51bGw7XG4gICAgdGhpcy5zdGFja01vdmVGcm9tVG8gPSB7fTtcbiAgfVxuICBfZ2V0RHJhZ2dpbmdJbmZvKGV2ZW50VGFyZ2V0KSB7XG4gICAgY29uc29sZS5sb2coJ3RoaXMuZXZlbnREaXJlY3Rpb24nLCB0aGlzLmV2ZW50RGlyZWN0aW9uLCBldmVudFRhcmdldCk7XG4gICAgaWYgKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBvYmogeyBmcm9tLCB0bywgZHJhZ2dhYmxlIH1cbiAgICAgIGxldCBvYmogPSBldmVudFRhcmdldC5jYW5Nb3ZlVG9TaWJsaW5nW3RoaXMuZXZlbnREaXJlY3Rpb25dO1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0gZXZlbnRUYXJnZXQuY2FuTW92ZVRvUGFyZW50W3RoaXMuZXZlbnREaXJlY3Rpb25dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajsgXG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuICBfcGFuc3RhcnQoZSkge1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgdGhpcy5ldmVudFRhcmdldCA9IHRoaXMuc3RhY2tzLmZpbmQoXG4gICAgICBzdGFjayA9PiBzdGFjay5ub2RlID09PSBlLmN1cnJlbnRUYXJnZXRcbiAgICApO1xuICAgIGlmICghdGhpcy5ldmVudFRhcmdldCkge1xuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5kcmFnU3RhcnQodGhpcyk7XG4gIH1cbiAgX3BhbmxlZnQoZSkge1xuICAgIGNvbnN0IGV2ZW50QXhpcyA9ICdob3Jpem9udGFsJztcbiAgICBpZiAodGhpcy5fYmxvY2tFdmVudChldmVudEF4aXMpKSByZXR1cm47XG4gICAgdGhpcy5pc0RpZmZlcmVudEV2ZW50ID0gdGhpcy5ldmVudERpcmVjdGlvbiAmJiB0aGlzLmV2ZW50RGlyZWN0aW9uICE9PSAnbGVmdCc7XG5cbiAgICB0aGlzLmV2ZW50RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgIC8vIGNvbnNvbGUubG9nKCdTVEFSVDonLCBldmVudFR5cGUuZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZyhlKTtcbiAgICB9XG4gIH1cbiAgX3BhbnJpZ2h0KGUpIHtcbiAgICBjb25zdCBldmVudEF4aXMgPSAnaG9yaXpvbnRhbCc7XG4gICAgaWYgKHRoaXMuX2Jsb2NrRXZlbnQoZXZlbnRBeGlzKSkgcmV0dXJuO1xuICAgIHRoaXMuaXNEaWZmZXJlbnRFdmVudCA9IHRoaXMuZXZlbnREaXJlY3Rpb24gJiYgdGhpcy5ldmVudERpcmVjdGlvbiAhPT0gJ3JpZ2h0JztcblxuICAgIHRoaXMuZXZlbnREaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgIC8vIGNvbnNvbGUubG9nKCdTVEFSVDonLCBldmVudFR5cGUuZGlyZWN0aW9uKTtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZyhlKTtcbiAgICB9XG4gIH1cbiAgX3BhbmRvd24oZSkge1xuICAgIGNvbnN0IGV2ZW50QXhpcyA9ICd2ZXJ0aWNhbCc7XG4gICAgaWYgKHRoaXMuX2Jsb2NrRXZlbnQoZXZlbnRBeGlzKSkgcmV0dXJuO1xuICAgIHRoaXMuaXNEaWZmZXJlbnRFdmVudCA9IHRoaXMuZXZlbnREaXJlY3Rpb24gJiYgdGhpcy5ldmVudERpcmVjdGlvbiAhPT0gJ2Rvd24nO1xuXG4gICAgdGhpcy5ldmVudERpcmVjdGlvbiA9ICdkb3duJztcbiAgICAvLyBjb25zb2xlLmxvZygnU1RBUlQ6JywgZXZlbnRUeXBlLmRpcmVjdGlvbiwgdGhpcy5kcmFnZ2luZ1JlZik7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nUmVmKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nSW5mbyA9IHRoaXMuX2dldERyYWdnaW5nSW5mbyh0aGlzLmV2ZW50VGFyZ2V0KTtcbiAgICAgIHRoaXMuZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nSW5mby5kcmFnZ2FibGU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nUmVmKSB7XG4gICAgICB0aGlzLl9yZXNldERyYWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhZ2dpbmcoZSk7XG4gICAgfVxuICB9XG4gIFxuICBfcGFudXAoZSkge1xuICAgIGNvbnN0IGV2ZW50QXhpcyA9ICd2ZXJ0aWNhbCc7XG4gICAgaWYgKHRoaXMuX2Jsb2NrRXZlbnQoZXZlbnRBeGlzKSkgcmV0dXJuO1xuICAgIHRoaXMuaXNEaWZmZXJlbnRFdmVudCA9IHRoaXMuZXZlbnREaXJlY3Rpb24gJiYgdGhpcy5ldmVudERpcmVjdGlvbiAhPT0gJ3VwJztcbiAgICB0aGlzLmV2ZW50RGlyZWN0aW9uID0gJ3VwJztcbiAgICAvLyBjb25zb2xlLmxvZygnZnJvbSB0bycsIGRhdGEuZnJvbSwgZGF0YS50byk7XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZyhlKTtcbiAgICB9XG4gIH1cbiAgX2VuZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHsgc3RhY2tNb3ZlRnJvbVRvIH0gPSB0aGlzO1xuICAgIGNvbnNvbGUubG9nKCdfZW5kQ2FsbGJhY2sgc3RhY2tNb3ZlRnJvbVRvJywgc3RhY2tNb3ZlRnJvbVRvKTtcbiAgICBpZiAoc3RhY2tNb3ZlRnJvbVRvLmZyb20gIT09IHN0YWNrTW92ZUZyb21Uby50bykge1xuICAgICAgaWYgKHN0YWNrTW92ZUZyb21Uby50b1BhcmVudCkge1xuICAgICAgICBzdGFja01vdmVGcm9tVG8udG9QYXJlbnQubGFzdFNlZW5JbmRleCA9IHN0YWNrTW92ZUZyb21Uby50bztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50SWR4ID0gc3RhY2tNb3ZlRnJvbVRvLnRvO1xuICAgIHRoaXMub3B0aW9ucy5kcmFnRW5kKHRoaXMpO1xuICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICB9XG4gIF9wYW5lbmQoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1NUQVJUOiBwYW5lbmQnLCB0aGlzLmV2ZW50VHlwZSwgISF0aGlzLmRyYWdnaW5nUmVmKTtcbiAgICBpZiAodGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgLy8gZ3NhcCDsvZzrsLHrgrTsl5DshJwgdGhpcy5kcmFnZ2luZ1JlZiDsnZgg6rCS7J20IG51bGwg7J20IOuQoCDqsIDriqXshLHsnbQg7KG07J6s7ZWY66+A66GcXG4gICAgICAvLyDrk5zrnpjquYXrkJjripQg6rCd7LK07J2YIOyjvOyGjOyngOulvCDrs4DsiJjroZwg7KCA7J6l7ZW07IScIOyCrOyaqVxuICAgICAgY29uc3QgZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nUmVmO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5ldmVudERpcmVjdGlvbjtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gZHJhZ2dpbmdSZWY7XG4gICAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG4gICAgICBjb25zdCB0ID0gdGhpcy5kZXAuZ3NhcC50aW1lbGluZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgICAgIGlmIChkcmFnZ2luZ1JlZi5wb3NpdGlvbnMudG9wICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyB0b3A6IC1jbGllbnRIZWlnaHQgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy50b3AgPSAtY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dpbmdSZWYucG9zaXRpb25zLnRvcCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFja01vdmVGcm9tVG8udG8gPSB0aGlzLnN0YWNrTW92ZUZyb21Uby5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0LnRvKGRyYWdnaW5nUmVmLm5vZGUsIHsgdG9wOiAwIH0pLmFkZCgoKSA9PiB7XG4gICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMudG9wID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgaWYgKGRyYWdnaW5nUmVmLnBvc2l0aW9ucy5sZWZ0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IGxlZnQ6IC1jbGllbnRXaWR0aCB9KS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLmxlZnQgPSAtY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dpbmdSZWYucG9zaXRpb25zLmxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvLnRvID0gdGhpcy5zdGFja01vdmVGcm9tVG8uZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IGxlZnQ6IDAgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd5Jykge1xuICAgICAgICBjb25zdCBnYXAgPSBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMueSAtIHRoaXMuc25hcHNob3RQb3NpdGlvbnMueTtcbiAgICAgICAgY29uc3QgeSA9IGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55O1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgY29uc3QgY2FuTmV4dCA9IHRoaXMuc25hcHNob3RQb3NpdGlvbnMueSA8IHk7XG4gICAgICAgICAgbGV0IG1vdmUgPSB5O1xuICAgICAgICAgIGlmIChjYW5OZXh0KSB7XG4gICAgICAgICAgICBtb3ZlID0geSAtIGNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IC1jbGllbnRIZWlnaHQgKiAoZHJhZ2dpbmdSZWYuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAobW92ZSA8IG1heCkgbW92ZSA9IG1heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2FwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFja01vdmVGcm9tVG8udG8gPSB0aGlzLnN0YWNrTW92ZUZyb21Uby5mcm9tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyB5OiBtb3ZlIH0pLmFkZCgoKSA9PiB7XG4gICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMueSA9IG1vdmU7XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgIGNvbnN0IGNhbk5leHQgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zLnkgPiB5O1xuICAgICAgICAgIGxldCBtb3ZlID0geTtcbiAgICAgICAgICBpZiAoY2FuTmV4dCkge1xuICAgICAgICAgICAgbW92ZSA9IHkgKyBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAobW92ZSA+PSAwKSBtb3ZlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvLnRvID0gdGhpcy5zdGFja01vdmVGcm9tVG8uZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IHk6IG1vdmUgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55ID0gbW92ZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd4Jykge1xuICAgICAgICBjb25zdCB4ID0gZHJhZ2dpbmdSZWYucG9zaXRpb25zLng7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGNvbnN0IGNhbk5leHQgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zLnggPCB4O1xuXG4gICAgICAgICAgbGV0IG1vdmUgPSB4O1xuICAgICAgICAgIGlmIChjYW5OZXh0KSB7XG4gICAgICAgICAgICBtb3ZlID0geCAtIGNsaWVudFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gLWNsaWVudFdpZHRoICogKGRyYWdnaW5nUmVmLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKG1vdmUgPCBtYXgpIG1vdmUgPSBtYXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvLnRvID0gdGhpcy5zdGFja01vdmVGcm9tVG8uZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IHg6IG1vdmUgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy54ID0gbW92ZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGNvbnN0IGNhbk5leHQgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zLnggPiB4O1xuICAgICAgICAgIGxldCBtb3ZlID0geDtcbiAgICAgICAgICBpZiAoY2FuTmV4dCkge1xuICAgICAgICAgICAgbW92ZSA9IHggKyBjbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGlmIChtb3ZlID49IDApIG1vdmUgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyB4OiBtb3ZlIH0pLmFkZCgoKSA9PiB7XG4gICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMueCA9IG1vdmU7XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICAgIH1cbiAgfVxuICAvLyB0aGlzLmRpc3RhbmNlIOqwkuyXkCDrlLDrnbwg65Oc656Y6re4IOqwgOuPmeuylOychCDshYvtjIUg6rCA64ql7ZWY64+E66GdXG4gIC8vIE1hdGguYWJzKGUuZGVsdGFZKSwgTWF0aC5hYnMoZS5kZWx0YVgpXG4gIF9kcmFnZ2luZyhlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kcmFnZ2luZ1JlZjtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHRhcmdldDtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG5cbiAgICB0aGlzLnNuYXBzaG90UG9zaXRpb25zID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zO1xuICAgIGxldCBwb3NZLCBwb3NYO1xuXG4gICAgXG4gICAgaWYgKHRoaXMuaXNEaWZmZXJlbnRFdmVudCkge1xuICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAneScpIHtcbiAgICAgIHBvc1kgPSBlLmRlbHRhWSArIHRhcmdldC5wb3NpdGlvbnMueTtcblxuICAgICAgaWYgKHBvc1kgPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLnkgPSAwO1xuICAgICAgICB0YXJnZXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xuICAgICAgICBjb25zb2xlLmxvZygndGhpcy5pc0RpZmZlcmVudEV2ZW50MicsIHRoaXMuaXNEaWZmZXJlbnRFdmVudCk7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8oc3RhY2tWaWV3KTtcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g6rK96rOE66m0IOydtOuPmeyLnCDrsoTqt7g/XG4gICAgICAgIGNvbnN0IG1heCA9IC1jbGllbnRIZWlnaHQgKiAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAocG9zWSA8PSBtYXgpIHtcbiAgICAgICAgICB0YXJnZXQucG9zaXRpb25zLnkgPSBtYXg7XG4gICAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDBweCwgJHttYXh9cHgsIDBweClgO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCd0aGlzLmlzRGlmZmVyZW50RXZlbnQxJywgdGhpcy5pc0RpZmZlcmVudEV2ZW50KTtcbiAgICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8oc3RhY2tWaWV3KTtcbiAgICAgICAgICAvLyB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygndGhpcy5pc0RpZmZlcmVudEV2ZW50MycsIHRoaXMuaXNEaWZmZXJlbnRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIOyLpOygnCDqt7jroKTsp5BcbiAgICAgIHBvc2l0aW9ucy55ID0gcG9zWTtcbiAgICAgIHRoaXMuZGVwLmdzYXAuc2V0KHRhcmdldC5ub2RlLCB7IHk6IHBvc1kgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgIHBvc1ggPSBlLmRlbHRhWCArIHRhcmdldC5wb3NpdGlvbnMueDtcbiAgICAgIGlmIChwb3NYID49IDApIHtcbiAgICAgICAgdGFyZ2V0LnBvc2l0aW9ucy54ID0gMDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpJztcbiAgICAgICAgLy8gY2hhbmdlIGRyYWdnaW5nIHRhcmdldFxuICAgICAgICAvLyB0aGlzLmRyYWdnaW5nSW5mbyA9IHRoaXMuX2dldERyYWdnaW5nSW5mbyhzdGFja1ZpZXcpO1xuICAgICAgICAvLyB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtYXggPSAtY2xpZW50V2lkdGggKiAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHBvc1ggPD0gbWF4KSB7XG4gICAgICAgIHRhcmdldC5wb3NpdGlvbnMueCA9IG1heDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7bWF4fXB4LCAwcHgsIDBweClgO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIC8vIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHN0YWNrVmlldyk7XG4gICAgICAgIC8vIHRoaXMuZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nSW5mby5kcmFnZ2FibGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9ucy54ID0gcG9zWDtcbiAgICAgIHRoaXMuZGVwLmdzYXAuc2V0KHRhcmdldC5ub2RlLCB7IHg6IHBvc1ggfSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgcG9zWSA9IGUuZGVsdGFZICsgdGFyZ2V0LnBvc2l0aW9ucy50b3A7XG4gICAgICBpZiAocG9zWSA+PSAwKSB7XG4gICAgICAgIHRhcmdldC5wb3NpdGlvbnMudG9wID0gMDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudG9wID0gMCArICdweCc7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8oc3RhY2tWaWV3KTtcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBvc1kgPD0gLWNsaWVudEhlaWdodCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLnRvcCA9IC1jbGllbnRIZWlnaHQ7XG4gICAgICAgIHRhcmdldC5ub2RlLnN0eWxlLnRvcCA9IC1jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIC8vIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHN0YWNrVmlldyk7XG4gICAgICAgIC8vIHRoaXMuZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nSW5mby5kcmFnZ2FibGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb25zLnRvcCA9IHBvc1k7XG4gICAgICB0aGlzLmRlcC5nc2FwLnNldCh0YXJnZXQubm9kZSwgeyB0b3A6IHBvc1kgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgcG9zWCA9IHRhcmdldC5wb3NpdGlvbnMubGVmdCArIGUuZGVsdGFYO1xuICAgICAgaWYgKHBvc1ggPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLmxlZnQgPSAwO1xuICAgICAgICB0YXJnZXQubm9kZS5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8oc3RhY2tWaWV3KTtcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBvc1ggPD0gLWNsaWVudFdpZHRoKSB7XG4gICAgICAgIHRhcmdldC5wb3NpdGlvbnMubGVmdCA9IC1jbGllbnRXaWR0aDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUubGVmdCA9IC1jbGllbnRXaWR0aCArICdweCc7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8oc3RhY2tWaWV3KTtcbiAgICAgICAgLy8gdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbnMubGVmdCA9IHBvc1g7XG4gICAgICB0aGlzLmRlcC5nc2FwLnNldCh0YXJnZXQubm9kZSwgeyBsZWZ0OiBwb3NYIH0pO1xuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdfZHJhZ2dpbmcnLCB0eXBlLCB0aGlzLmV2ZW50RGlyZWN0aW9uLCBwb3NZLCB0aGlzLmV2ZW50VGFyZ2V0LCB0aGlzLmRyYWdnaW5nSW5mbyk7XG5cbiAgICB0aGlzLnN0YWNrTW92ZUZyb21UbyA9IHRoaXMuX2dldFN0YWNrTW92ZUZyb21UbygpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdkcmFnZ2luZyBzdGFja01vdmVGcm9tVG8nLCB0aGlzLnN0YWNrTW92ZUZyb21Ubyk7XG5cbiAgICB0aGlzLm9wdGlvbnMuZHJhZ01vdmUodGhpcyk7XG4gICAgLy8gdG9wIOydmCDqsr3smrDsi5xcbiAgICAvLyBzaWJsaW5nSW5kZXggMCwgcG9zWSAwLCAtMSwgLTIsIC4uLiAtPiBlbmQgRXZlbnQg7IucIC02NjdcbiAgICAvLyBzaWJsaW5nSW5kZXggMCDqsJLsnYAg7KCQ7KCQIGhpZGUsIHNsaWJsaW5naW5kZXggMeqwkuydgCDtlZjri6gg67aA7YSwIOygkOygkCDrhbjstpxcbiAgfVxuICBfZ2V0U3RhY2tNb3ZlRnJvbVRvKCkge1xuICAgIGNvbnN0IHsgZnJvbSwgdG8sIGNoYW5nZWFibGVUbyB9ID0gdGhpcy5kcmFnZ2luZ0luZm87XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZnJvbSxcbiAgICB9O1xuICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0b1BhcmVudCA9IHRoaXMuc3RhY2tzW3RvXS5pbm5lclBhcmVudDtcbiAgICAgIHJlc3VsdC50byA9IHRvO1xuICAgICAgcmVzdWx0LnRvUGFyZW50ID0gdG9QYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2VhYmxlVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdG9QYXJlbnQgPSB0aGlzLnN0YWNrc1tjaGFuZ2VhYmxlVG9dLmlubmVyUGFyZW50O1xuICAgICAgcmVzdWx0LnRvID0gdG9QYXJlbnQubGFzdFNlZW5JbmRleCA/IHRvUGFyZW50Lmxhc3RTZWVuSW5kZXggOiBjaGFuZ2VhYmxlVG87XG4gICAgICByZXN1bHQudG9QYXJlbnQgPSB0b1BhcmVudDtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ2Zyb20nLCBmcm9tLCB0bywgY2hhbmdlYWJsZVRvLCByZXN1bHQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9hZGRFdmVudHMoKSB7XG4gICAgLy8gbW9iaWxlIOydvCDqsr3smrBcbiAgICAvLyB0b3VjaHN0YXJ0LCB0b3VjaG1vdmUsIHRvdWNoZW5kIDPqsIDsp4Ag65Ox66GdXG5cbiAgICAvLyBwYyDsnbwg6rK97JqwXG4gICAgLy8gRE9NTW91c2VTY3JvbGwgbW91c2V3aGVlbFxuICAgIC8vIG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwXG4gICAgLy8ga2V5ZG93blxuXG4gICAgLy8gcmVzaXplQ29tcGxldGUg7IucIGN1cnJlbnRJZHgg66GcIOydtOuPmVxuXG4gICAgY29uc3QgbWMgPSBuZXcgdGhpcy5kZXAuSGFtbWVyKHRoaXMuY29udGFpbmVyUmVmKTtcbiAgICAvLyBzYXZlIG1jIGluc3RhbmNlIGZvciByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIC0gbWMub2ZmKCk7XG4gICAgdGhpcy5oYW1tZXJzLnB1c2gobWMpO1xuICAgIG1jLmFkZChcbiAgICAgIG5ldyB0aGlzLmRlcC5IYW1tZXIuUGFuKHtcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRlcC5IYW1tZXIuRElSRUNUSU9OX0FMTCxcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLm9wdGlvbnMudGhyZXNob2xkXG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gY29uc29sZS5sb2coMik7XG5cbiAgICAvLyBIYW1tZXIgcGFuIGV2ZW50IGlzc3VlIDogbm90IHN1cHBvcnQgZXZlbnQuY3VycmVudFRhcmdldFxuICAgIHRoaXMuc3RhY2tzLmZvckVhY2goKHsgbm9kZSB9KSA9PiB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9wYW5zdGFydC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBtYy5vbigncGFuZW5kJywgdGhpcy5fcGFuZW5kLmJpbmQodGhpcykpO1xuICAgIG1jLm9uKCdwYW5sZWZ0JywgdGhpcy5fcGFubGVmdC5iaW5kKHRoaXMpKTtcbiAgICBtYy5vbigncGFucmlnaHQnLCB0aGlzLl9wYW5yaWdodC5iaW5kKHRoaXMpKTtcbiAgICBtYy5vbigncGFuZG93bicsIHRoaXMuX3BhbmRvd24uYmluZCh0aGlzKSk7XG4gICAgbWMub24oJ3BhbnVwJywgdGhpcy5fcGFudXAuYmluZCh0aGlzKSk7XG4gIH1cbiAgc2V0Q29tbW9uTGF5b3V0KCkge1xuICAgIC8vIEJsb2NrIHgseSBzY3JvbGxpbmdcbiAgICAvLyBSZXF1aXJlZCBpbiBTYW1zdW5nIEludGVybmV0IGJyb3dzZXJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcblxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICB9XG4gIHNldExheW91dCgpIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gRnVsbHBhZ2VTd2lwZXIuZ2V0Vmlld3BvcnQoKTtcbiAgICAvLyDrtoDrqqgg7Luo7YWM7J2064SIIGxheW91dFxuICAgIHRoaXMucGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAvLyBkYXRhLXN0YWNrLXR5cGUg7JeQIOuUsOudvCBsYXlvdXQgc2V0dGluZ1xuICAgICAgLy8geCwgeSwgdG9wLCBsZWZ0XG4gICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgdGhpcy5fbGF5b3V0WChwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICd5JzpcbiAgICAgICAgdGhpcy5fbGF5b3V0WShwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRoaXMuX2xheW91dEZpeGVkKHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfbGF5b3V0WChwYXJlbnQpIHtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG4gICAgY29uc3QgeyBub2RlLCBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIG5vZGUueCA9IG5vZGUueSA9IDA7XG4gICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBub2RlLnN0eWxlLndpZHRoID0gY2xpZW50V2lkdGggKiBjaGlsZHJlbi5sZW5ndGggKyAncHgnO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpJztcbiAgICBjaGlsZHJlbi5mb3JFYWNoKCh7IG5vZGUgfSkgPT4ge1xuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IGNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICB9KTtcbiAgfVxuICBfbGF5b3V0WShwYXJlbnQpIHtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCB7IG5vZGUsIGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbm9kZS54ID0gbm9kZS55ID0gMDtcbiAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjbGllbnRIZWlnaHQgKiBjaGlsZHJlbi5sZW5ndGggKyAncHgnO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpJztcbiAgICBjaGlsZHJlbi5mb3JFYWNoKCh7IG5vZGUgfSkgPT4ge1xuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjbGllbnRIZWlnaHQgKyAncHgnO1xuICAgIH0pO1xuICB9XG4gIF9sYXlvdXRGaXhlZChwYXJlbnQpIHtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG4gICAgY29uc3QgeyBub2RlLCBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9IGNsaWVudEhlaWdodCArICdweCc7XG4gICAgbm9kZS5zdHlsZS53aWR0aCA9IGNsaWVudFdpZHRoICsgJ3B4JztcblxuICAgIGNoaWxkcmVuLmZvckVhY2goKHsgbm9kZSB9LCBpZHgsIGFycikgPT4ge1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBub2RlLnN0eWxlLnRvcCA9IDA7XG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IGNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgIG5vZGUuc3R5bGUuekluZGV4ID0gKGFyci5sZW5ndGggLSBpZHgpICogMTA7XG4gICAgfSk7XG4gIH1cbiAgc2V0UGFyZW50cygpIHtcbiAgICB0aGlzLnBhcmVudHMgPSBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3RhY2stdHlwZV0nKVxuICAgICkubWFwKHBhcmVudCA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gcGFyZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGFjay10eXBlJyk7XG4gICAgICBjb25zdCBheGlzID1cbiAgICAgICAgdHlwZSA9PT0gJ3RvcCcgfHwgdHlwZSA9PT0gJ3knID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcblxuICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAvLyBpZiBwYXJlbnQgaXMgcm9vdCBwYXJlbnRcbiAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMuY29udGFpbmVyUmVmKSB7XG4gICAgICAgIGNoaWxkcmVuID0gQXJyYXlcbiAgICAgICAgICAuZnJvbShwYXJlbnQuY2hpbGRyZW4pXG4gICAgICAgICAgLmZpbHRlcihlbCA9PiB0eXBlb2YgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrJykgPT09ICdzdHJpbmcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gQXJyYXlcbiAgICAgICAgICAuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3RhY2tdJykpXG4gICAgICAgICAgLmZpbHRlcihlbCA9PiB0eXBlb2YgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrJykgPT09ICdzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgYXhpcyxcbiAgICAgICAgbm9kZTogcGFyZW50LFxuICAgICAgICBpc1Jvb3Q6IHBhcmVudCA9PT0gdGhpcy5jb250YWluZXJSZWYsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzZXRTdGFja3MoKSB7XG4gICAgLy8gZmlsdGVyIGZ1bmN0aW9uIC0gb25seSBbZGF0YS1zdGFja10gZWxlbWVudFxuICAgIGNvbnN0IGZpbHRlciA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgaXNTdGFjayA9XG4gICAgICAgIG5vZGUgJiYgdHlwZW9mIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrJykgPT09ICdzdHJpbmcnO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBpc1N0YWNrXG4gICAgICAgID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUXG4gICAgICAgIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgIHRoaXMuY29udGFpbmVyUmVmLFxuICAgICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG4gICAgICBmaWx0ZXIsXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBub2RlIGlzIFtkYXRhLXN0YWNrXSBlbGVtZW50XG4gICAgbGV0IG5vZGUgPSB3YWxrZXIuZmlyc3RDaGlsZCgpO1xuICAgIGxldCBpZHggPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGxldCB0eXBlO1xuICAgICAgd2hpbGUgKHBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgdHlwZSA9IHBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrLXR5cGUnKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzVmVydGljYWwgPSB0eXBlID09PSAndG9wJyB8fCB0eXBlID09PSAneSc7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBpc1ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICAgIGNvbnN0IGlubmVyUGFyZW50SW5kZXggPSB0aGlzLnBhcmVudHMuZmluZEluZGV4KHAgPT4gcC5ub2RlID09PSBwYXJlbnROb2RlKTtcbiAgICAgIGNvbnN0IGlubmVyUGFyZW50ID0gdGhpcy5wYXJlbnRzW2lubmVyUGFyZW50SW5kZXhdO1xuXG4gICAgICBpZiAoaW5uZXJQYXJlbnQubm9kZSA9PT0gdGhpcy5jb250YWluZXJSZWYpIHtcbiAgICAgICAgaW5uZXJQYXJlbnQub3V0ZXJQYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGF0YS1zdGFjayAodGhpcyBpcyBvdXRlclBhcmVudCkgPiBkYXRhLXN0YWNrLXR5cGUgKHRoaXMgaXMgaW5uZXJQYXJlbnQpXG4gICAgICAgIGNvbnN0IG91dGVyUGFyZW50ID0gdGhpcy5wYXJlbnRzWzBdLmNoaWxkcmVuLmZpbmQob3V0ZXIgPT4ge1xuICAgICAgICAgIHJldHVybiBvdXRlci5ub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXN0YWNrLXR5cGVdJykgPT09IHBhcmVudE5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0ZXJQYXJlbnQpIHtcbiAgICAgICAgICBpbm5lclBhcmVudC5vdXRlclBhcmVudCA9IG91dGVyUGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpYmxpbmdJbmRleCA9IGlubmVyUGFyZW50LmNoaWxkcmVuLmZpbmRJbmRleChlbCA9PiBlbCA9PT0gbm9kZSk7XG4gICAgICBjb25zdCBzdGFja1ZpZXcgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGF4aXM6IGRpcmVjdGlvbixcbiAgICAgICAgbm9kZSwgLy8gZm9yIGUudGFyZ2V0XG4gICAgICAgIGlubmVyUGFyZW50LFxuICAgICAgICBpbm5lclBhcmVudEluZGV4LFxuICAgICAgICBpc1Jvb3RMZXZlbFN0YWNrOiBpbm5lclBhcmVudC5pc1Jvb3QsXG4gICAgICAgIGNoaWxkcmVuOiBpbm5lclBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgaXNGaXJzdE5vZGU6IHNpYmxpbmdJbmRleCA9PT0gMCxcbiAgICAgICAgaXNMYXN0Tm9kZTogc2libGluZ0luZGV4ID09PSBpbm5lclBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgc2libGluZ0luZGV4LFxuICAgICAgfTtcbiAgICAgIGlubmVyUGFyZW50LmNoaWxkcmVuW3NpYmxpbmdJbmRleF0gPSBzdGFja1ZpZXc7XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gd2Fsa2VyLmZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHdhbGtlci5wYXJlbnROb2RlKCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXN0YWNrVmlldy5pc1Jvb3RMZXZlbFN0YWNrKSB7XG4gICAgICAgIHN0YWNrVmlldy5zdGFja0luZGV4ID0gaWR4Kys7XG4gICAgICAgIHN0YWNrVmlldy5jYW5Nb3ZlVG9TaWJsaW5nID0gdGhpcy5fY2FuTW92ZVRvU2libGluZyhzdGFja1ZpZXcpO1xuICAgICAgICB0aGlzLnN0YWNrcy5wdXNoKHN0YWNrVmlldyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFja3MuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5jYW5Nb3ZlVG9QYXJlbnQgPSB0aGlzLl9jYW5Nb3ZlVG9QYXJlbnQoaXRlbSk7XG4gICAgfSk7XG4gIH1cbiAgX2Nhbk1vdmVUb1BhcmVudChzdGFjaykge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLnBhcmVudHNbMF0uYXhpcztcbiAgICBjb25zdCB0eXBlID0gdGhpcy5wYXJlbnRzWzBdLnR5cGU7XG5cbiAgICBjb25zdCB7IGNhbk1vdmVUb1NpYmxpbmcsIGlubmVyUGFyZW50LCBpbm5lclBhcmVudEluZGV4IH0gPSBzdGFjaztcbiAgICBjb25zdCB7IG91dGVyUGFyZW50IH0gPSBpbm5lclBhcmVudDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB1cDogIWNhbk1vdmVUb1NpYmxpbmcudXAgJiYgYXhpcyA9PT0gJ3ZlcnRpY2FsJyAmJiAhb3V0ZXJQYXJlbnQuaXNMYXN0Tm9kZSxcbiAgICAgIGRvd246ICFjYW5Nb3ZlVG9TaWJsaW5nLmRvd24gJiYgYXhpcyA9PT0gJ3ZlcnRpY2FsJyAmJiAhb3V0ZXJQYXJlbnQuaXNGaXJzdE5vZGUsXG4gICAgICBsZWZ0OiAhY2FuTW92ZVRvU2libGluZy5sZWZ0ICYmIGF4aXMgPT09ICdob3Jpem9udGFsJyAmJiAhb3V0ZXJQYXJlbnQuaXNMYXN0Tm9kZSxcbiAgICAgIHJpZ2h0OiAhY2FuTW92ZVRvU2libGluZy5yaWdodCAmJiBheGlzID09PSAnaG9yaXpvbnRhbCcgJiYgIW91dGVyUGFyZW50LmlzRmlyc3ROb2RlXG4gICAgfTtcblxuICAgIGlmIChyZXN1bHQudXApIHtcbiAgICAgIHJlc3VsdC51cCA9IHsgXG4gICAgICAgIGZyb206IHN0YWNrLnN0YWNrSW5kZXhcbiAgICAgIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIHJlc3VsdC51cC5kcmFnZ2FibGUgPSBvdXRlclBhcmVudC5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICByZXN1bHQudXAuZHJhZ2dhYmxlID0gb3V0ZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gdGhpcy5wYXJlbnRzW2lubmVyUGFyZW50SW5kZXggKyAxXTtcbiAgICAgIGlmIChuZXh0UGFyZW50LmF4aXMgPT09IGF4aXMpIHtcbiAgICAgICAgcmVzdWx0LnVwLnRvID0gbmV4dFBhcmVudC5jaGlsZHJlblswXS5zdGFja0luZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnVwLmNoYW5nZWFibGVUbyA9IG5leHRQYXJlbnQuY2hpbGRyZW5bMF0uc3RhY2tJbmRleDtcbiAgICAgICAgLy8g64+E7LCp7KeA6rCAIOuLpOuluCDstpXsnbgg6rK97JqwXG4gICAgICAgIC8vIC0gdmVydGljYWwgLT4gaG9yaXpvbnRhbFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0LmxlZnQpIHtcbiAgICAgIHJlc3VsdC5sZWZ0ID0geyBcbiAgICAgICAgZnJvbTogc3RhY2suc3RhY2tJbmRleFxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgICAgcmVzdWx0LmxlZnQuZHJhZ2dhYmxlID0gb3V0ZXJQYXJlbnQuaW5uZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHJlc3VsdC5sZWZ0LmRyYWdnYWJsZSA9IG91dGVyUGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHRoaXMucGFyZW50c1tpbm5lclBhcmVudEluZGV4ICsgMV07XG4gICAgICBpZiAobmV4dFBhcmVudC5heGlzID09PSBheGlzKSB7XG4gICAgICAgIHJlc3VsdC5sZWZ0LnRvID0gbmV4dFBhcmVudC5jaGlsZHJlblswXS5zdGFja0luZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g64+E7LCp7KeA6rCAIOuLpOuluCDstpXsnbgg6rK97JqwXG4gICAgICAgIC8vIC0gaG9yaXpvbnRhbCAtPiB2ZXJ0aWNhbFxuICAgICAgICByZXN1bHQubGVmdC5jaGFuZ2VhYmxlVG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuWzBdLnN0YWNrSW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5kb3duKSB7XG4gICAgICByZXN1bHQuZG93biA9IHsgXG4gICAgICAgIGZyb206IHN0YWNrLnN0YWNrSW5kZXhcbiAgICAgIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIHJlc3VsdC5kb3duLmRyYWdnYWJsZSA9IG91dGVyUGFyZW50LmlubmVyUGFyZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHRoaXMucGFyZW50c1tpbm5lclBhcmVudEluZGV4IC0gMV07XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlID0gbmV4dFBhcmVudC5vdXRlclBhcmVudDtcbiAgICAgICAgcmVzdWx0LmRvd24uZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRQYXJlbnQuYXhpcyA9PT0gYXhpcykge1xuICAgICAgICByZXN1bHQuZG93bi50byA9IG5leHRQYXJlbnQuY2hpbGRyZW5bbmV4dFBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdGFja0luZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g64+E7LCp7KeA6rCAIOuLpOuluCDstpXsnbgg6rK97JqwXG4gICAgICAgIC8vIC0gaG9yaXpvbnRhbCAtPiB2ZXJ0aWNhbFxuICAgICAgICByZXN1bHQuZG93bi5jaGFuZ2VhYmxlVG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuW25leHRQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3RhY2tJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnJpZ2h0KSB7XG4gICAgICByZXN1bHQucmlnaHQgPSB7IFxuICAgICAgICBmcm9tOiBzdGFjay5zdGFja0luZGV4XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGUgPT09ICd4Jykge1xuICAgICAgICByZXN1bHQucmlnaHQuZHJhZ2dhYmxlID0gb3V0ZXJQYXJlbnQuaW5uZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gdGhpcy5wYXJlbnRzW2lubmVyUGFyZW50SW5kZXggLSAxXTtcbiAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlID0gbmV4dFBhcmVudC5vdXRlclBhcmVudDtcbiAgICAgICAgcmVzdWx0LnJpZ2h0LmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UGFyZW50LmF4aXMgPT09IGF4aXMpIHtcbiAgICAgICAgcmVzdWx0LnJpZ2h0LnRvID0gbmV4dFBhcmVudC5jaGlsZHJlbltuZXh0UGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN0YWNrSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDrj4TssKnsp4DqsIAg64uk66W4IOy2leyduCDqsr3smrBcbiAgICAgICAgLy8gLSB2ZXJ0aWNhbCAtPiBob3Jpem9udGFsXG4gICAgICAgIHJlc3VsdC5yaWdodC5jaGFuZ2VhYmxlVG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuW25leHRQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3RhY2tJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9jYW5Nb3ZlVG9TaWJsaW5nKHN0YWNrKSB7XG4gICAgY29uc3QgYXhpcyA9IHN0YWNrLmlubmVyUGFyZW50LmF4aXM7XG4gICAgY29uc3QgdHlwZSA9IHN0YWNrLmlubmVyUGFyZW50LnR5cGU7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgdXA6IGF4aXMgPT09ICd2ZXJ0aWNhbCcgJiYgIXN0YWNrLmlzTGFzdE5vZGUsXG4gICAgICBkb3duOiBheGlzID09PSAndmVydGljYWwnICYmICFzdGFjay5pc0ZpcnN0Tm9kZSxcbiAgICAgIGxlZnQ6IGF4aXMgPT09ICdob3Jpem9udGFsJyAmJiAhc3RhY2suaXNMYXN0Tm9kZSxcbiAgICAgIHJpZ2h0OiBheGlzID09PSAnaG9yaXpvbnRhbCcgJiYgIXN0YWNrLmlzRmlyc3ROb2RlLFxuICAgIH07XG4gICAgaWYgKHJlc3VsdC51cCkge1xuICAgICAgcmVzdWx0LnVwID0geyBcbiAgICAgICAgZnJvbTogc3RhY2suc3RhY2tJbmRleCwgdG86IHN0YWNrLnN0YWNrSW5kZXggKyAxXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGUgPT09ICd5Jykge1xuICAgICAgICByZXN1bHQudXAuZHJhZ2dhYmxlID0gc3RhY2suaW5uZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcmVzdWx0LnVwLmRyYWdnYWJsZSA9IHN0YWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0LmxlZnQpIHtcbiAgICAgIHJlc3VsdC5sZWZ0ID0geyBmcm9tOiBzdGFjay5zdGFja0luZGV4LCB0bzogc3RhY2suc3RhY2tJbmRleCArIDEgfTtcbiAgICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgICAgcmVzdWx0LmxlZnQuZHJhZ2dhYmxlID0gc3RhY2suaW5uZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHJlc3VsdC5sZWZ0LmRyYWdnYWJsZSA9IHN0YWNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQuZG93bikge1xuICAgICAgcmVzdWx0LmRvd24gPSB7IGZyb206IHN0YWNrLnN0YWNrSW5kZXgsIHRvOiBzdGFjay5zdGFja0luZGV4IC0gMSB9O1xuICAgICAgaWYgKHR5cGUgPT09ICd5Jykge1xuICAgICAgICByZXN1bHQuZG93bi5kcmFnZ2FibGUgPSBzdGFjay5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICByZXN1bHQuZG93bi5kcmFnZ2FibGUgPSB0aGlzLnN0YWNrc1tzdGFjay5zdGFja0luZGV4IC0gMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQucmlnaHQpIHtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHsgZnJvbTogc3RhY2suc3RhY2tJbmRleCwgdG86IHN0YWNrLnN0YWNrSW5kZXggLSAxIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHJlc3VsdC5yaWdodC5kcmFnZ2FibGUgPSBzdGFjay5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmVzdWx0LnJpZ2h0LmRyYWdnYWJsZSA9IHRoaXMuc3RhY2tzW3N0YWNrLnN0YWNrSW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuIFxuICBkZWJ1ZygpIHtcbiAgICB0aGlzLnN0YWNrcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gRnVsbHBhZ2VTd2lwZXIuZ2V0UmFuZG9tQ29sb3IoKTtcbiAgICAgIGVsLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZygnU1RBQ0tfUEFSRU5UUzogJywgdGhpcy5wYXJlbnRzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKCdTVEFDS19WSUVXOiAnLCB0aGlzLnN0YWNrcyk7XG4gICAgd2luZG93LmZwcyA9IHRoaXM7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/index.js\n");

/***/ })

})