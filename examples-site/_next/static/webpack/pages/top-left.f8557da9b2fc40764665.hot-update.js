webpackHotUpdate_N_E("pages/top-left",{

/***/ "../src/index.js":
/*!***********************!*\
  !*** ../src/index.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FullpageSwiper; });\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ \"../node_modules/hammerjs/hammer.js\");\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap */ \"../node_modules/gsap/index.js\");\n\n\n\nclass FullpageSwiper {\n  static getViewport() {\n    return {\n      // webview issue - undefined : window.innerWidth, window.innerHeight\n      clientWidth: window.innerWidth || document.documentElement.clientWidth,\n      clientHeight: window.innerHeight || document.documentElement.clientHeight\n    };\n  }\n  static getRandomColor() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n  constructor(selector, options = {}) {\n    this.containerRef = document.querySelector(selector);\n    this.containerType = this.containerRef.getAttribute('data-stack-type');\n    if (!(this.containerRef && this.containerType)) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'fullpage-swiper initialization error, check selector',\n        selector\n      );\n      return;\n    }\n    if (!hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a || !gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '\"Hammer\" and \"gsap\" peerDependencies are required'\n      );\n      return;\n    }\n    this.dep = { Hammer: (hammerjs__WEBPACK_IMPORTED_MODULE_0___default()), gsap: gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"] };\n    this.containerAxis =\n      this.containerType === 'top' || this.containerType === 'y'\n        ? 'vertical'\n        : 'horizontal';\n\n    this.options = Object.assign({ debug: false }, options);\n\n    this.parents = [];\n    this.stacks = [];\n    this.hammers = [];\n\n    this.currentIdx = 0;\n    this.eventAxis = '';\n    this.eventDirection = '';\n    this.dragging = false;\n    this.draggingRef = null;\n\n    this.viewport = FullpageSwiper.getViewport();\n\n    this.setParents();\n    this.setStacks();\n    this.setCommonLayout();\n    this.setLayout();\n\n    this.resizeCallback = this._resizeCallback.bind(this);\n    this._addEvents();\n    this.options.debug && this.debug();\n  }\n  clear() {\n    window.removeEventListener('resize', this.resizeCallback);\n  }\n  _blockEvent(eventAxis) {\n    // 최초 이벤트 요청일 경우 블록 X\n    if (this.eventAxis === '') {\n      this.eventAxis = eventAxis;\n      return false;\n    }\n    // 1.드래깅중이 아닐 경우 이벤트 블록\n    // 2. 진행중인 드래깅이 존재하는 경우, 요청 이벤트 타입이 동일하지 않으면 블록\n    if (!this.isDragging || this.eventAxis !== eventAxis) {\n      // console.log('blocked event', eventType);\n      return true;\n    }\n\n    // 동일한 axis의 드래깅중인 경우 업데이트\n    this.eventAxis = eventAxis;\n  }\n  _resetDrag() {\n    this.dragging = false;\n    this.eventAxis = '';\n    this.eventDirection = '';\n    this.draggingRef = null;\n    this.stackMoveFromTo = {};\n  }\n  _getDraggingInfo(eventTarget) {\n    if (eventTarget) {\n      // obj { from, to, draggable }\n      let obj = eventTarget.canMoveToSibling[this.eventDirection];\n      if (!obj) {\n        obj = eventTarget.canMoveToParent[this.eventDirection];\n      }\n      return obj; \n    }\n    return {};\n  }\n  _panstart(e) {\n    this.isDragging = true;\n    this.eventTarget = this.stacks.find(\n      stack => stack.node === e.currentTarget\n    );\n    if (!this.eventTarget) {\n      this.isDragging = false;\n      return;\n    }\n    this.options.dragStart(this);\n  }\n  _panleft(e) {\n    const eventAxis = 'horizontal';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'left';\n\n    this.eventDirection = 'left';\n    // console.log('START:', eventType.direction);\n    \n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _panright(e) {\n    const eventAxis = 'horizontal';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'right';\n\n    this.eventDirection = 'right';\n    // console.log('START:', eventType.direction);\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _pandown(e) {\n    const eventAxis = 'vertical';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'down';\n\n    this.eventDirection = 'down';\n    // console.log('START:', eventType.direction, this.draggingRef);\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  \n  _panup(e) {\n    const eventAxis = 'vertical';\n    if (this._blockEvent(eventAxis)) return;\n    this.isDifferentEvent = this.eventDirection && this.eventDirection !== 'up';\n    this.eventDirection = 'up';\n    // console.log('from to', data.from, data.to);\n\n    if (!this.draggingRef) {\n      this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n      this.draggingRef = this.draggingInfo.draggable;\n    }\n\n    if (!this.draggingRef) {\n      this._resetDrag();\n    } else {\n      this._dragging(e);\n    }\n  }\n  _endCallback() {\n    const { stackMoveFromTo } = this;\n    if (stackMoveFromTo.from !== stackMoveFromTo.to) {\n      if (stackMoveFromTo.toParent) {\n        stackMoveFromTo.toParent.lastSeenIndex = stackMoveFromTo.to;\n      }\n    }\n    this.currentIdx = stackMoveFromTo.to;\n    this.options.dragEnd(this);\n    this._resetDrag();\n  }\n  _panend() {\n    if (this.draggingRef) {\n      // gsap 콜백내에서 this.draggingRef 의 값이 null 이 될 가능성이 존재하므로\n      // 드래깅되는 객체의 주소지를 변수로 저장해서 사용\n      const draggingRef = this.draggingRef;\n      const direction = this.eventDirection;\n      const { type } = draggingRef;\n      const { clientHeight, clientWidth } = this.viewport;\n      const t = gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].timeline();\n\n      if (type === 'top') {\n        if (direction === 'up') {\n          if (draggingRef.positions.top !== 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { top: -clientHeight }).add(() => {\n            draggingRef.positions.top = -clientHeight;\n            draggingRef.positions.topResize = -1;\n            this._endCallback();\n          });\n        }\n        if (direction === 'down') {\n          if (draggingRef.positions.top === 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { top: 0 }).add(() => {\n            draggingRef.positions.top = 0;\n            delete draggingRef.positions.topResize;\n            this._endCallback();\n          });\n        }\n      }\n      if (type === 'left') {\n        if (direction === 'left') {\n          if (draggingRef.positions.left !== 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n\n          t.to(draggingRef.node, { left: -clientWidth }).add(() => {\n            draggingRef.positions.left = -clientWidth;\n            draggingRef.positions.leftResize = -1;\n            this._endCallback();\n          });\n        }\n        if (direction === 'right') {\n          if (draggingRef.positions.left === 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { left: 0 }).add(() => {\n            draggingRef.positions.left = 0;\n            delete draggingRef.positions.leftResize;\n            this._endCallback();\n          });\n        }\n      }\n\n      if (type === 'y') {\n        const gap = draggingRef.positions.y - this.snapshotPositions.y;\n        const y = draggingRef.positions.y;\n        if (direction === 'up') {\n          const canNext = this.snapshotPositions.y < y;\n          let move = y;\n          if (canNext) {\n            move = y - clientHeight;\n            const max = -clientHeight * (draggingRef.children.length - 1);\n            if (move < max) move = max;\n          }\n\n          if (gap < 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n\n          t.to(draggingRef.node, { y: move }).add(() => {\n            draggingRef.positions.y = move;\n            if (move !== 0) {\n              draggingRef.positions.yResize = move/clientHeight;\n            } else {\n              delete draggingRef.positions.yResize;\n            }\n            this._endCallback();\n          });\n        }\n        if (direction === 'down') {\n          const canNext = this.snapshotPositions.y > y;\n          let move = y;\n          if (canNext) {\n            move = y + clientHeight;\n            if (move >= 0) move = 0;\n          }\n          if (gap > 0) {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { y: move }).add(() => {\n            draggingRef.positions.y = move;\n            if (move !== 0) {\n              draggingRef.positions.yResize = move/clientHeight;\n            } else {\n              delete draggingRef.positions.yResize;\n            }\n            this._endCallback();\n          });\n        }\n      }\n\n      if (type === 'x') {\n        const x = draggingRef.positions.x;\n        if (direction === 'left') {\n          const canNext = this.snapshotPositions.x < x;\n\n          let move = x;\n          if (canNext) {\n            move = x - clientWidth;\n            const max = -clientWidth * (draggingRef.children.length - 1);\n            if (move < max) move = max;\n          } else {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { x: move }).add(() => {\n            draggingRef.positions.x = move;\n            if (move !== 0) {\n              draggingRef.positions.xResize = move/clientWidth;\n            } else {\n              delete draggingRef.positions.xResize;\n            }\n            this._endCallback();\n          });\n        }\n        if (direction === 'right') {\n          const canNext = this.snapshotPositions.x > x;\n          let move = x;\n          if (canNext) {\n            move = x + clientWidth;\n            if (move >= 0) move = 0;\n          } else {\n            this.stackMoveFromTo.to = this.stackMoveFromTo.from;\n          }\n          t.to(draggingRef.node, { x: move }).add(() => {\n            draggingRef.positions.x = move;\n            if (move !== 0) {\n              draggingRef.positions.xResize = move/clientWidth;\n            } else {\n              delete draggingRef.positions.xResize;\n            }\n            this._endCallback();\n          });\n        }\n      }\n    } else {\n      this._resetDrag();\n    }\n  }\n  // todo\n  // this.distance 값에 따라 드래그 가동범위 셋팅 가능하도록\n  // Math.abs(e.deltaY), Math.abs(e.deltaX)\n  _dragging(e) {\n    const target = this.draggingRef;\n    const { type } = target;\n    const { clientHeight, clientWidth } = this.viewport;\n\n    this.snapshotPositions = {\n      top: 0,\n      left: 0,\n      x: 0,\n      y: 0\n    };\n    const positions = this.snapshotPositions;\n    let posY, posX;\n    if (type === 'y') {\n      posY = e.deltaY + target.positions.y;\n\n      if (posY >= 0) {\n        target.positions.y = 0;\n        target.node.style.transform = 'translate3d(0px, 0px, 0px)';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      } else {\n        const max = -clientHeight * (target.children.length - 1);\n        if (posY <= max) {\n          target.positions.y = max;\n          target.node.style.transform = `translate3d(0px, ${max}px, 0px)`;\n          // change dragging target\n          this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n          this.draggingRef = this.draggingInfo.draggable;\n          return;\n        }\n      }\n\n      positions.y = posY;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(target.node, { y: posY });\n    }\n    if (type === 'x') {\n      posX = e.deltaX + target.positions.x;\n      if (posX >= 0) {\n        target.positions.x = 0;\n        target.node.style.transform = 'translate3d(0px, 0px, 0px)';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      const max = -clientWidth * (target.children.length - 1);\n      if (posX <= max) {\n        target.positions.x = max;\n        target.node.style.transform = `translate3d(${max}px, 0px, 0px)`;\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      positions.x = posX;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(target.node, { x: posX });\n    }\n    if (type === 'top') {\n      posY = e.deltaY + target.positions.top;\n      if (posY >= 0) {\n        target.positions.top = 0;\n        target.node.style.top = 0 + 'px';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      if (posY <= -clientHeight) {\n        target.positions.top = -clientHeight;\n        target.node.style.top = -clientHeight + 'px';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n\n      positions.top = posY;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(target.node, { top: posY });\n    }\n\n    if (type === 'left') {\n      posX = target.positions.left + e.deltaX;\n      if (posX >= 0) {\n        target.positions.left = 0;\n        target.node.style.left = 0 + 'px';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n      if (posX <= -clientWidth) {\n        target.positions.left = -clientWidth;\n        target.node.style.left = -clientWidth + 'px';\n        // change dragging target\n        this.draggingInfo = this._getDraggingInfo(this.eventTarget);\n        this.draggingRef = this.draggingInfo.draggable;\n        return;\n      }\n\n      positions.left = posX;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(target.node, { left: posX });\n    }\n\n    if (this.isDifferentEvent) {\n      const draggingInfo = this._getDraggingInfo(this.eventTarget);\n      if (draggingInfo) this.draggingInfo = draggingInfo;\n    }\n    this.stackMoveFromTo = this._getStackMoveFromTo();\n    this.options.dragMove(this);\n    // top 의 경우시\n    // siblingIndex 0, posY 0, -1, -2, ... -> end Event 시 -667\n    // siblingIndex 0 값은 점점 hide, sliblingindex 1값은 하단 부터 점점 노출\n  }\n  _getStackMoveFromTo() {\n    const { from, to, changeableTo } = this.draggingInfo;\n    const result = {\n      from,\n    };\n    if (to !== undefined) {\n      const toParent = this.stacks[to].innerParent;\n      result.to = to;\n      result.toParent = toParent;\n    } else if (changeableTo !== undefined) {\n      const toParent = this.stacks[changeableTo].innerParent;\n      result.to = toParent.lastSeenIndex ? toParent.lastSeenIndex : changeableTo;\n      result.toParent = toParent;\n    }\n    return result;\n  }\n\n  _addEvents() {\n    // mobile 일 경우\n    // touchstart, touchmove, touchend 3가지 등록\n\n    // pc 일 경우\n    // DOMMouseScroll mousewheel\n    // mousedown, mousemove, mouseup\n    // keydown\n\n    // resizeComplete 시 currentIdx 로 이동\n\n    const mc = new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a(this.containerRef);\n    // save mc instance for remove event listeners - mc.off();\n    this.hammers.push(mc);\n    mc.add(\n      new hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.Pan({\n        direction: hammerjs__WEBPACK_IMPORTED_MODULE_0___default.a.DIRECTION_ALL,\n        threshold: this.options.threshold\n      })\n    );\n\n    // Hammer pan event issue : not support event.currentTarget\n    this.stacks.forEach(({ node }) => {\n      node.addEventListener('touchstart', this._panstart.bind(this), false);\n    });\n\n    mc.on('panend', this._panend.bind(this));\n    mc.on('panleft', this._panleft.bind(this));\n    mc.on('panright', this._panright.bind(this));\n    mc.on('pandown', this._pandown.bind(this));\n    mc.on('panup', this._panup.bind(this));\n\n    window.addEventListener('resize', this.resizeCallback);\n    window.addEventListener('orientationchange', this.rotationCallback);\n  }\n  _rotationCallback() {\n    console.log('orientationchange');\n    this.timer && clearInterval(this.timer);\n    let max = 0;\n    this.timer = setInterval(() => {\n      const viewport = FullpageSwiper.getViewport();\n      if (this.viewport.clientHeight !== viewport.clientHeight) {\n        this.timer && clearInterval(this.timer);\n        this.timer = null;\n        this._resizeCallback();\n      } else {\n        if (max >= 10) {\n          this.timer && clearInterval(this.timer);\n          this.timer = null;\n        }\n        max++;\n      }\n    }, 60);\n  }\n  _resizeCallback(e) {\n    this.setCommonLayout();\n    this.setLayout();\n        // Positions update\n    const root = this.parents[0];\n    this._updatePositions(root);\n    root.children.forEach((child) => {\n      this._updatePositions(child);\n    });\n    this.stacks.forEach((s) => {\n      this._updatePositions(s);\n      this._updatePositions(s.innerParent);\n    });\n    \n  }\n  _updatePositions({ positions, node }) {\n    const { clientHeight, clientWidth } = this.viewport;\n    const { yResize, topResize, xResize, leftResize } = positions;\n    if (yResize) {\n      positions.y = yResize * clientHeight;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(node, { y: positions.y });\n    }\n    if (topResize) {\n      positions.top = topResize * clientHeight;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(node, { top: positions.top });\n    }\n    if (xResize) {\n      positions.x = xResize * clientWidth;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(node, { x: positions.x });\n    }\n    if (leftResize) {\n      positions.left = leftResize * clientWidth;\n      gsap__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(node, { left: positions.left });\n    }\n  }\n  setCommonLayout() {\n    this.viewport = FullpageSwiper.getViewport();\n    // Block x,y scrolling\n    // Required in Samsung Internet browser\n    document.documentElement.style.overflow = 'hidden';\n    document.documentElement.style.height = '100%';\n    document.documentElement.style.width = '100%';\n\n    document.body.style.overflow = 'hidden';\n    document.body.style.height = '100%';\n    document.body.style.width = '100%';\n  }\n  setLayout() {\n    // 부모 컨테이너 layout\n    this.parents.forEach(parent => {\n      // data-stack-type 에 따라 layout setting\n      // x, y, top, left\n      switch (parent.type) {\n      case 'x':\n        this._layoutX(parent);\n        return;\n      case 'y':\n        this._layoutY(parent);\n        return;\n      case 'top':\n      case 'left':\n        this._layoutFixed(parent);\n        return;\n      }\n    });\n  }\n  _layoutX(parent) {\n    const { clientHeight, clientWidth } = this.viewport;\n    const { node, children } = parent;\n    node.x = node.y = 0;\n    node.style.display = 'flex';\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.width = clientWidth * children.length + 'px';\n    node.style.transform = 'translate3d(0px, 0px, 0px)';\n    children.forEach(({ node }) => {\n      node.style.width = clientWidth + 'px';\n      node.style.height = clientHeight + 'px';\n    });\n  }\n  _layoutY(parent) {\n    const { clientHeight } = this.viewport;\n    const { node, children } = parent;\n    node.x = node.y = 0;\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.height = clientHeight * children.length + 'px';\n    node.style.transform = 'translate3d(0px, 0px, 0px)';\n    children.forEach(({ node }) => {\n      node.style.height = clientHeight + 'px';\n    });\n  }\n  _layoutFixed(parent) {\n    const { clientHeight, clientWidth } = this.viewport;\n    const { node, children } = parent;\n    node.style.overflow = 'hidden';\n    node.style.position = 'relative';\n    node.style.height = clientHeight + 'px';\n    node.style.width = clientWidth + 'px';\n\n    children.forEach(({ node }, idx, arr) => {\n      node.style.position = 'absolute';\n      node.style.top = 0;\n      node.style.left = 0;\n      node.style.height = clientHeight + 'px';\n      node.style.width = clientWidth + 'px';\n      node.style.zIndex = (arr.length - idx) * 10;\n    });\n  }\n  setParents() {\n    this.parents = Array.from(\n      document.querySelectorAll('[data-stack-type]')\n    ).map(parent => {\n      const type = parent.getAttribute('data-stack-type');\n      const axis =\n        type === 'top' || type === 'y' ? 'vertical' : 'horizontal';\n\n      let children = [];\n      // if parent is root parent\n      if (parent === this.containerRef) {\n        children = Array\n          .from(parent.children)\n          .filter(el => typeof el.getAttribute('data-stack') === 'string');\n      } else {\n        children = Array\n          .from(parent.querySelectorAll('[data-stack]'))\n          .filter(el => typeof el.getAttribute('data-stack') === 'string');\n      }\n\n      return {\n        type,\n        axis,\n        node: parent,\n        isRoot: parent === this.containerRef,\n        children,\n        positions: {\n          x: 0,\n          y: 0,\n          top: 0,\n          left: 0\n        }\n      };\n    });\n  }\n  setStacks() {\n    // filter function - only [data-stack] element\n    const filter = node => {\n      const isStack =\n        node && typeof node.getAttribute('data-stack') === 'string';\n      \n      const result = isStack\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP;\n     \n      return result;\n    };\n    \n    const walker = document.createTreeWalker(\n      this.containerRef,\n      NodeFilter.SHOW_ELEMENT,\n      filter,\n      false\n    );\n\n    // node is [data-stack] element\n    let node = walker.firstChild();\n    let idx = 0;\n    while (node !== null) {\n      let parentNode = node.parentNode;\n      let type;\n      while (parentNode !== null) {\n        type = parentNode.getAttribute('data-stack-type');\n        if (type) {\n          break;\n        } else {\n          parentNode = parentNode.parentNode;\n        }\n      }\n\n      const isVertical = type === 'top' || type === 'y';\n      const direction = isVertical ? 'vertical' : 'horizontal';\n      const innerParentIndex = this.parents.findIndex(p => p.node === parentNode);\n      const innerParent = this.parents[innerParentIndex];\n\n      if (innerParent.node === this.containerRef) {\n        innerParent.outerParent = null;\n      } else {\n        // data-stack (this is outerParent) > data-stack-type (this is innerParent)\n        const outerParent = this.parents[0].children.find(outer => {\n          return outer.node.querySelector('[data-stack-type]') === parentNode;\n        });\n        if (outerParent) {\n          innerParent.outerParent = outerParent;\n        }\n      }\n\n      const siblingIndex = innerParent.children.findIndex(el => el === node);\n      const stackView = {\n        type,\n        axis: direction,\n        node, // for e.target\n        innerParent,\n        innerParentIndex,\n        isRootLevelStack: innerParent.isRoot,\n        children: innerParent.children,\n        isFirstNode: siblingIndex === 0,\n        isLastNode: siblingIndex === innerParent.children.length - 1,\n        positions: {\n          x: 0,\n          y: 0,\n          top: 0,\n          left: 0\n        },\n        siblingIndex,\n      };\n      innerParent.children[siblingIndex] = stackView;\n\n      const child = walker.firstChild();\n      if (child) {\n        node = child;\n      } else {\n        const next = walker.nextSibling();\n        if (next) {\n          node = next;\n        } else {\n          if (walker.parentNode()) {\n            node = walker.nextSibling();\n          } else {\n            node = null;\n          }\n        }\n      }\n      if (!stackView.isRootLevelStack) {\n        stackView.stackIndex = idx++;\n        stackView.canMoveToSibling = this._canMoveToSibling(stackView);\n        this.stacks.push(stackView);\n      }\n    }\n\n    this.stacks.forEach((item) => {\n      item.canMoveToParent = this._canMoveToParent(item);\n    });\n  }\n  _canMoveToParent(stack) {\n    const axis = this.parents[0].axis;\n    const type = this.parents[0].type;\n\n    const { canMoveToSibling, innerParent, innerParentIndex } = stack;\n    const { outerParent } = innerParent;\n    const result = {\n      up: !canMoveToSibling.up && axis === 'vertical' && !outerParent.isLastNode,\n      down: !canMoveToSibling.down && axis === 'vertical' && !outerParent.isFirstNode,\n      left: !canMoveToSibling.left && axis === 'horizontal' && !outerParent.isLastNode,\n      right: !canMoveToSibling.right && axis === 'horizontal' && !outerParent.isFirstNode\n    };\n\n    if (result.up) {\n      result.up = { \n        from: stack.stackIndex\n      };\n      if (type === 'y') {\n        result.up.draggable = outerParent.innerParent;\n      }\n      if (type === 'top') {\n        result.up.draggable = outerParent;\n      }\n      const nextParent = this.parents[innerParentIndex + 1];\n      if (nextParent.axis === axis) {\n        result.up.to = nextParent.children[0].stackIndex;\n      } else {\n        result.up.changeableTo = nextParent.children[0].stackIndex;\n        // 도착지가 다른 축인 경우\n        // - vertical -> horizontal\n      }\n    }\n    if (result.left) {\n      result.left = { \n        from: stack.stackIndex\n      };\n      if (type === 'x') {\n        result.left.draggable = outerParent.innerParent;\n      }\n      if (type === 'left') {\n        result.left.draggable = outerParent;\n      }\n      const nextParent = this.parents[innerParentIndex + 1];\n      if (nextParent.axis === axis) {\n        result.left.to = nextParent.children[0].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - horizontal -> vertical\n        result.left.changeableTo = nextParent.children[0].stackIndex;\n      }\n    }\n\n    if (result.down) {\n      result.down = { \n        from: stack.stackIndex\n      };\n      if (type === 'y') {\n        result.down.draggable = outerParent.innerParent;\n      }\n      const nextParent = this.parents[innerParentIndex - 1];\n      if (type === 'top') {\n        const draggable = nextParent.outerParent;\n        result.down.draggable = draggable;\n      }\n      if (nextParent.axis === axis) {\n        result.down.to = nextParent.children[nextParent.children.length - 1].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - horizontal -> vertical\n        result.down.changeableTo = nextParent.children[nextParent.children.length - 1].stackIndex;\n      }\n    }\n\n    if (result.right) {\n      result.right = { \n        from: stack.stackIndex\n      };\n      if (type === 'x') {\n        result.right.draggable = outerParent.innerParent;\n      }\n      const nextParent = this.parents[innerParentIndex - 1];\n      if (type === 'left') {\n        const draggable = nextParent.outerParent;\n        result.right.draggable = draggable;\n      }\n      if (nextParent.axis === axis) {\n        result.right.to = nextParent.children[nextParent.children.length - 1].stackIndex;\n      } else {\n        // 도착지가 다른 축인 경우\n        // - vertical -> horizontal\n        result.right.changeableTo \n          = nextParent.children[nextParent.children.length - 1].stackIndex;\n      }\n    }\n\n    return result;\n  }\n  _canMoveToSibling(stack) {\n    const axis = stack.innerParent.axis;\n    const type = stack.innerParent.type;\n    const result = {\n      up: axis === 'vertical' && !stack.isLastNode,\n      down: axis === 'vertical' && !stack.isFirstNode,\n      left: axis === 'horizontal' && !stack.isLastNode,\n      right: axis === 'horizontal' && !stack.isFirstNode,\n    };\n    if (result.up) {\n      result.up = { \n        from: stack.stackIndex, to: stack.stackIndex + 1\n      };\n      if (type === 'y') {\n        result.up.draggable = stack.innerParent;\n      }\n      if (type === 'top') {\n        result.up.draggable = stack;\n      }\n    }\n    if (result.left) {\n      result.left = { from: stack.stackIndex, to: stack.stackIndex + 1 };\n      if (type === 'x') {\n        result.left.draggable = stack.innerParent;\n      }\n      if (type === 'left') {\n        result.left.draggable = stack;\n      }\n    }\n\n    if (result.down) {\n      result.down = { from: stack.stackIndex, to: stack.stackIndex - 1 };\n      if (type === 'y') {\n        result.down.draggable = stack.innerParent;\n      }\n      if (type === 'top') {\n        result.down.draggable = this.stacks[stack.stackIndex - 1];\n      }\n    }\n    if (result.right) {\n      result.right = { from: stack.stackIndex, to: stack.stackIndex - 1 };\n      if (type === 'x') {\n        result.right.draggable = stack.innerParent;\n      }\n      if (type === 'left') {\n        result.right.draggable = this.stacks[stack.stackIndex - 1];\n      }\n    }\n    return result;\n  }\n \n  debug() {\n    this.stacks.forEach(el => {\n      const color = FullpageSwiper.getRandomColor();\n      el.node.style.backgroundColor = color;\n    });\n    // eslint-disable-next-line no-console\n    console.log('STACK_PARENTS: ', this.parents);\n    // eslint-disable-next-line no-console\n    console.log('STACK_VIEW: ', this.stacks);\n    window.fps = this;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9pbmRleC5qcz9hMTc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEI7QUFDTjs7QUFFVDtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFNLEtBQUssNENBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLENBQUMseURBQU0sRUFBRSxrREFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsZUFBZTs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsa0RBQWtEO0FBQzdELFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhhbW1lciBmcm9tICdoYW1tZXJqcyc7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVsbHBhZ2VTd2lwZXIge1xuICBzdGF0aWMgZ2V0Vmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIHdlYnZpZXcgaXNzdWUgLSB1bmRlZmluZWQgOiB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0XG4gICAgICBjbGllbnRXaWR0aDogd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldFJhbmRvbUNvbG9yKCkge1xuICAgIGNvbnN0IGxldHRlcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRic7XG4gICAgbGV0IGNvbG9yID0gJyMnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICBjb25zdHJ1Y3RvcihzZWxlY3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb250YWluZXJSZWYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB0aGlzLmNvbnRhaW5lclR5cGUgPSB0aGlzLmNvbnRhaW5lclJlZi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2stdHlwZScpO1xuICAgIGlmICghKHRoaXMuY29udGFpbmVyUmVmICYmIHRoaXMuY29udGFpbmVyVHlwZSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnZnVsbHBhZ2Utc3dpcGVyIGluaXRpYWxpemF0aW9uIGVycm9yLCBjaGVjayBzZWxlY3RvcicsXG4gICAgICAgIHNlbGVjdG9yXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUhhbW1lciB8fCAhZ3NhcCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdcIkhhbW1lclwiIGFuZCBcImdzYXBcIiBwZWVyRGVwZW5kZW5jaWVzIGFyZSByZXF1aXJlZCdcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVwID0geyBIYW1tZXIsIGdzYXAgfTtcbiAgICB0aGlzLmNvbnRhaW5lckF4aXMgPVxuICAgICAgdGhpcy5jb250YWluZXJUeXBlID09PSAndG9wJyB8fCB0aGlzLmNvbnRhaW5lclR5cGUgPT09ICd5J1xuICAgICAgICA/ICd2ZXJ0aWNhbCdcbiAgICAgICAgOiAnaG9yaXpvbnRhbCc7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZGVidWc6IGZhbHNlIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJlbnRzID0gW107XG4gICAgdGhpcy5zdGFja3MgPSBbXTtcbiAgICB0aGlzLmhhbW1lcnMgPSBbXTtcblxuICAgIHRoaXMuY3VycmVudElkeCA9IDA7XG4gICAgdGhpcy5ldmVudEF4aXMgPSAnJztcbiAgICB0aGlzLmV2ZW50RGlyZWN0aW9uID0gJyc7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dpbmdSZWYgPSBudWxsO1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IEZ1bGxwYWdlU3dpcGVyLmdldFZpZXdwb3J0KCk7XG5cbiAgICB0aGlzLnNldFBhcmVudHMoKTtcbiAgICB0aGlzLnNldFN0YWNrcygpO1xuICAgIHRoaXMuc2V0Q29tbW9uTGF5b3V0KCk7XG4gICAgdGhpcy5zZXRMYXlvdXQoKTtcblxuICAgIHRoaXMucmVzaXplQ2FsbGJhY2sgPSB0aGlzLl9yZXNpemVDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2FkZEV2ZW50cygpO1xuICAgIHRoaXMub3B0aW9ucy5kZWJ1ZyAmJiB0aGlzLmRlYnVnKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplQ2FsbGJhY2spO1xuICB9XG4gIF9ibG9ja0V2ZW50KGV2ZW50QXhpcykge1xuICAgIC8vIOy1nOy0iCDsnbTrsqTtirgg7JqU7LKt7J28IOqyveyasCDruJTroZ0gWFxuICAgIGlmICh0aGlzLmV2ZW50QXhpcyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZXZlbnRBeGlzID0gZXZlbnRBeGlzO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAxLuuTnOuemOq5heykkeydtCDslYTri5Ag6rK97JqwIOydtOuypO2KuCDruJTroZ1cbiAgICAvLyAyLiDsp4TtlonspJHsnbgg65Oc656Y6rmF7J20IOyhtOyerO2VmOuKlCDqsr3smrAsIOyalOyyrSDsnbTrsqTtirgg7YOA7J6F7J20IOuPmeydvO2VmOyngCDslYrsnLzrqbQg67iU66GdXG4gICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcgfHwgdGhpcy5ldmVudEF4aXMgIT09IGV2ZW50QXhpcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Jsb2NrZWQgZXZlbnQnLCBldmVudFR5cGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g64+Z7J287ZWcIGF4aXPsnZgg65Oc656Y6rmF7KSR7J24IOqyveyasCDsl4XrjbDsnbTtirhcbiAgICB0aGlzLmV2ZW50QXhpcyA9IGV2ZW50QXhpcztcbiAgfVxuICBfcmVzZXREcmFnKCkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50QXhpcyA9ICcnO1xuICAgIHRoaXMuZXZlbnREaXJlY3Rpb24gPSAnJztcbiAgICB0aGlzLmRyYWdnaW5nUmVmID0gbnVsbDtcbiAgICB0aGlzLnN0YWNrTW92ZUZyb21UbyA9IHt9O1xuICB9XG4gIF9nZXREcmFnZ2luZ0luZm8oZXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoZXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIG9iaiB7IGZyb20sIHRvLCBkcmFnZ2FibGUgfVxuICAgICAgbGV0IG9iaiA9IGV2ZW50VGFyZ2V0LmNhbk1vdmVUb1NpYmxpbmdbdGhpcy5ldmVudERpcmVjdGlvbl07XG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICBvYmogPSBldmVudFRhcmdldC5jYW5Nb3ZlVG9QYXJlbnRbdGhpcy5ldmVudERpcmVjdGlvbl07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqOyBcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIF9wYW5zdGFydChlKSB7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gdGhpcy5zdGFja3MuZmluZChcbiAgICAgIHN0YWNrID0+IHN0YWNrLm5vZGUgPT09IGUuY3VycmVudFRhcmdldFxuICAgICk7XG4gICAgaWYgKCF0aGlzLmV2ZW50VGFyZ2V0KSB7XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLmRyYWdTdGFydCh0aGlzKTtcbiAgfVxuICBfcGFubGVmdChlKSB7XG4gICAgY29uc3QgZXZlbnRBeGlzID0gJ2hvcml6b250YWwnO1xuICAgIGlmICh0aGlzLl9ibG9ja0V2ZW50KGV2ZW50QXhpcykpIHJldHVybjtcbiAgICB0aGlzLmlzRGlmZmVyZW50RXZlbnQgPSB0aGlzLmV2ZW50RGlyZWN0aW9uICYmIHRoaXMuZXZlbnREaXJlY3Rpb24gIT09ICdsZWZ0JztcblxuICAgIHRoaXMuZXZlbnREaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgLy8gY29uc29sZS5sb2coJ1NUQVJUOicsIGV2ZW50VHlwZS5kaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5fcmVzZXREcmFnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nKGUpO1xuICAgIH1cbiAgfVxuICBfcGFucmlnaHQoZSkge1xuICAgIGNvbnN0IGV2ZW50QXhpcyA9ICdob3Jpem9udGFsJztcbiAgICBpZiAodGhpcy5fYmxvY2tFdmVudChldmVudEF4aXMpKSByZXR1cm47XG4gICAgdGhpcy5pc0RpZmZlcmVudEV2ZW50ID0gdGhpcy5ldmVudERpcmVjdGlvbiAmJiB0aGlzLmV2ZW50RGlyZWN0aW9uICE9PSAncmlnaHQnO1xuXG4gICAgdGhpcy5ldmVudERpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgLy8gY29uc29sZS5sb2coJ1NUQVJUOicsIGV2ZW50VHlwZS5kaXJlY3Rpb24pO1xuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5fcmVzZXREcmFnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nKGUpO1xuICAgIH1cbiAgfVxuICBfcGFuZG93bihlKSB7XG4gICAgY29uc3QgZXZlbnRBeGlzID0gJ3ZlcnRpY2FsJztcbiAgICBpZiAodGhpcy5fYmxvY2tFdmVudChldmVudEF4aXMpKSByZXR1cm47XG4gICAgdGhpcy5pc0RpZmZlcmVudEV2ZW50ID0gdGhpcy5ldmVudERpcmVjdGlvbiAmJiB0aGlzLmV2ZW50RGlyZWN0aW9uICE9PSAnZG93bic7XG5cbiAgICB0aGlzLmV2ZW50RGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgIC8vIGNvbnNvbGUubG9nKCdTVEFSVDonLCBldmVudFR5cGUuZGlyZWN0aW9uLCB0aGlzLmRyYWdnaW5nUmVmKTtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmdSZWYpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RHJhZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZyhlKTtcbiAgICB9XG4gIH1cbiAgXG4gIF9wYW51cChlKSB7XG4gICAgY29uc3QgZXZlbnRBeGlzID0gJ3ZlcnRpY2FsJztcbiAgICBpZiAodGhpcy5fYmxvY2tFdmVudChldmVudEF4aXMpKSByZXR1cm47XG4gICAgdGhpcy5pc0RpZmZlcmVudEV2ZW50ID0gdGhpcy5ldmVudERpcmVjdGlvbiAmJiB0aGlzLmV2ZW50RGlyZWN0aW9uICE9PSAndXAnO1xuICAgIHRoaXMuZXZlbnREaXJlY3Rpb24gPSAndXAnO1xuICAgIC8vIGNvbnNvbGUubG9nKCdmcm9tIHRvJywgZGF0YS5mcm9tLCBkYXRhLnRvKTtcblxuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kcmFnZ2luZ1JlZikge1xuICAgICAgdGhpcy5fcmVzZXREcmFnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nKGUpO1xuICAgIH1cbiAgfVxuICBfZW5kQ2FsbGJhY2soKSB7XG4gICAgY29uc3QgeyBzdGFja01vdmVGcm9tVG8gfSA9IHRoaXM7XG4gICAgaWYgKHN0YWNrTW92ZUZyb21Uby5mcm9tICE9PSBzdGFja01vdmVGcm9tVG8udG8pIHtcbiAgICAgIGlmIChzdGFja01vdmVGcm9tVG8udG9QYXJlbnQpIHtcbiAgICAgICAgc3RhY2tNb3ZlRnJvbVRvLnRvUGFyZW50Lmxhc3RTZWVuSW5kZXggPSBzdGFja01vdmVGcm9tVG8udG87XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudElkeCA9IHN0YWNrTW92ZUZyb21Uby50bztcbiAgICB0aGlzLm9wdGlvbnMuZHJhZ0VuZCh0aGlzKTtcbiAgICB0aGlzLl9yZXNldERyYWcoKTtcbiAgfVxuICBfcGFuZW5kKCkge1xuICAgIGlmICh0aGlzLmRyYWdnaW5nUmVmKSB7XG4gICAgICAvLyBnc2FwIOy9nOuwseuCtOyXkOyEnCB0aGlzLmRyYWdnaW5nUmVmIOydmCDqsJLsnbQgbnVsbCDsnbQg65CgIOqwgOuKpeyEseydtCDsobTsnqztlZjrr4DroZxcbiAgICAgIC8vIOuTnOuemOq5heuQmOuKlCDqsJ3ssrTsnZgg7KO87IaM7KeA66W8IOuzgOyImOuhnCDsoIDsnqXtlbTshJwg7IKs7JqpXG4gICAgICBjb25zdCBkcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdSZWY7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmV2ZW50RGlyZWN0aW9uO1xuICAgICAgY29uc3QgeyB0eXBlIH0gPSBkcmFnZ2luZ1JlZjtcbiAgICAgIGNvbnN0IHsgY2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aCB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICAgIGNvbnN0IHQgPSBnc2FwLnRpbWVsaW5lKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgaWYgKGRyYWdnaW5nUmVmLnBvc2l0aW9ucy50b3AgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvLnRvID0gdGhpcy5zdGFja01vdmVGcm9tVG8uZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IHRvcDogLWNsaWVudEhlaWdodCB9KS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnRvcCA9IC1jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMudG9wUmVzaXplID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgIGlmIChkcmFnZ2luZ1JlZi5wb3NpdGlvbnMudG9wID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyB0b3A6IDAgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy50b3AgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy50b3BSZXNpemU7XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGlmIChkcmFnZ2luZ1JlZi5wb3NpdGlvbnMubGVmdCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFja01vdmVGcm9tVG8udG8gPSB0aGlzLnN0YWNrTW92ZUZyb21Uby5mcm9tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyBsZWZ0OiAtY2xpZW50V2lkdGggfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy5sZWZ0ID0gLWNsaWVudFdpZHRoO1xuICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLmxlZnRSZXNpemUgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGlmIChkcmFnZ2luZ1JlZi5wb3NpdGlvbnMubGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFja01vdmVGcm9tVG8udG8gPSB0aGlzLnN0YWNrTW92ZUZyb21Uby5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0LnRvKGRyYWdnaW5nUmVmLm5vZGUsIHsgbGVmdDogMCB9KS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLmxlZnQgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy5sZWZ0UmVzaXplO1xuICAgICAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIGNvbnN0IGdhcCA9IGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55IC0gdGhpcy5zbmFwc2hvdFBvc2l0aW9ucy55O1xuICAgICAgICBjb25zdCB5ID0gZHJhZ2dpbmdSZWYucG9zaXRpb25zLnk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICBjb25zdCBjYW5OZXh0ID0gdGhpcy5zbmFwc2hvdFBvc2l0aW9ucy55IDwgeTtcbiAgICAgICAgICBsZXQgbW92ZSA9IHk7XG4gICAgICAgICAgaWYgKGNhbk5leHQpIHtcbiAgICAgICAgICAgIG1vdmUgPSB5IC0gY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gLWNsaWVudEhlaWdodCAqIChkcmFnZ2luZ1JlZi5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChtb3ZlIDwgbWF4KSBtb3ZlID0gbWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IHk6IG1vdmUgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55ID0gbW92ZTtcbiAgICAgICAgICAgIGlmIChtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55UmVzaXplID0gbW92ZS9jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnlSZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgIGNvbnN0IGNhbk5leHQgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zLnkgPiB5O1xuICAgICAgICAgIGxldCBtb3ZlID0geTtcbiAgICAgICAgICBpZiAoY2FuTmV4dCkge1xuICAgICAgICAgICAgbW92ZSA9IHkgKyBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAobW92ZSA+PSAwKSBtb3ZlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvLnRvID0gdGhpcy5zdGFja01vdmVGcm9tVG8uZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdC50byhkcmFnZ2luZ1JlZi5ub2RlLCB7IHk6IG1vdmUgfSkuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55ID0gbW92ZTtcbiAgICAgICAgICAgIGlmIChtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy55UmVzaXplID0gbW92ZS9jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnlSZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgICAgY29uc3QgeCA9IGRyYWdnaW5nUmVmLnBvc2l0aW9ucy54O1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBjb25zdCBjYW5OZXh0ID0gdGhpcy5zbmFwc2hvdFBvc2l0aW9ucy54IDwgeDtcblxuICAgICAgICAgIGxldCBtb3ZlID0geDtcbiAgICAgICAgICBpZiAoY2FuTmV4dCkge1xuICAgICAgICAgICAgbW92ZSA9IHggLSBjbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IC1jbGllbnRXaWR0aCAqIChkcmFnZ2luZ1JlZi5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChtb3ZlIDwgbWF4KSBtb3ZlID0gbWF4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrTW92ZUZyb21Uby50byA9IHRoaXMuc3RhY2tNb3ZlRnJvbVRvLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICAgIHQudG8oZHJhZ2dpbmdSZWYubm9kZSwgeyB4OiBtb3ZlIH0pLmFkZCgoKSA9PiB7XG4gICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMueCA9IG1vdmU7XG4gICAgICAgICAgICBpZiAobW92ZSAhPT0gMCkge1xuICAgICAgICAgICAgICBkcmFnZ2luZ1JlZi5wb3NpdGlvbnMueFJlc2l6ZSA9IG1vdmUvY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnhSZXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmRDYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBjb25zdCBjYW5OZXh0ID0gdGhpcy5zbmFwc2hvdFBvc2l0aW9ucy54ID4geDtcbiAgICAgICAgICBsZXQgbW92ZSA9IHg7XG4gICAgICAgICAgaWYgKGNhbk5leHQpIHtcbiAgICAgICAgICAgIG1vdmUgPSB4ICsgY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBpZiAobW92ZSA+PSAwKSBtb3ZlID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFja01vdmVGcm9tVG8udG8gPSB0aGlzLnN0YWNrTW92ZUZyb21Uby5mcm9tO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0LnRvKGRyYWdnaW5nUmVmLm5vZGUsIHsgeDogbW92ZSB9KS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnggPSBtb3ZlO1xuICAgICAgICAgICAgaWYgKG1vdmUgIT09IDApIHtcbiAgICAgICAgICAgICAgZHJhZ2dpbmdSZWYucG9zaXRpb25zLnhSZXNpemUgPSBtb3ZlL2NsaWVudFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGRyYWdnaW5nUmVmLnBvc2l0aW9ucy54UmVzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNldERyYWcoKTtcbiAgICB9XG4gIH1cbiAgLy8gdG9kb1xuICAvLyB0aGlzLmRpc3RhbmNlIOqwkuyXkCDrlLDrnbwg65Oc656Y6re4IOqwgOuPmeuylOychCDshYvtjIUg6rCA64ql7ZWY64+E66GdXG4gIC8vIE1hdGguYWJzKGUuZGVsdGFZKSwgTWF0aC5hYnMoZS5kZWx0YVgpXG4gIF9kcmFnZ2luZyhlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kcmFnZ2luZ1JlZjtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHRhcmdldDtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG5cbiAgICB0aGlzLnNuYXBzaG90UG9zaXRpb25zID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnNuYXBzaG90UG9zaXRpb25zO1xuICAgIGxldCBwb3NZLCBwb3NYO1xuICAgIGlmICh0eXBlID09PSAneScpIHtcbiAgICAgIHBvc1kgPSBlLmRlbHRhWSArIHRhcmdldC5wb3NpdGlvbnMueTtcblxuICAgICAgaWYgKHBvc1kgPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLnkgPSAwO1xuICAgICAgICB0YXJnZXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXggPSAtY2xpZW50SGVpZ2h0ICogKHRhcmdldC5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKHBvc1kgPD0gbWF4KSB7XG4gICAgICAgICAgdGFyZ2V0LnBvc2l0aW9ucy55ID0gbWF4O1xuICAgICAgICAgIHRhcmdldC5ub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwcHgsICR7bWF4fXB4LCAwcHgpYDtcbiAgICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZ1JlZiA9IHRoaXMuZHJhZ2dpbmdJbmZvLmRyYWdnYWJsZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcG9zaXRpb25zLnkgPSBwb3NZO1xuICAgICAgZ3NhcC5zZXQodGFyZ2V0Lm5vZGUsIHsgeTogcG9zWSB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICd4Jykge1xuICAgICAgcG9zWCA9IGUuZGVsdGFYICsgdGFyZ2V0LnBvc2l0aW9ucy54O1xuICAgICAgaWYgKHBvc1ggPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLnggPSAwO1xuICAgICAgICB0YXJnZXQubm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtYXggPSAtY2xpZW50V2lkdGggKiAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHBvc1ggPD0gbWF4KSB7XG4gICAgICAgIHRhcmdldC5wb3NpdGlvbnMueCA9IG1heDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7bWF4fXB4LCAwcHgsIDBweClgO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3NpdGlvbnMueCA9IHBvc1g7XG4gICAgICBnc2FwLnNldCh0YXJnZXQubm9kZSwgeyB4OiBwb3NYIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvc1kgPSBlLmRlbHRhWSArIHRhcmdldC5wb3NpdGlvbnMudG9wO1xuICAgICAgaWYgKHBvc1kgPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLnRvcCA9IDA7XG4gICAgICAgIHRhcmdldC5ub2RlLnN0eWxlLnRvcCA9IDAgKyAncHgnO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocG9zWSA8PSAtY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldC5wb3NpdGlvbnMudG9wID0gLWNsaWVudEhlaWdodDtcbiAgICAgICAgdGFyZ2V0Lm5vZGUuc3R5bGUudG9wID0gLWNsaWVudEhlaWdodCArICdweCc7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nSW5mby5kcmFnZ2FibGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb25zLnRvcCA9IHBvc1k7XG4gICAgICBnc2FwLnNldCh0YXJnZXQubm9kZSwgeyB0b3A6IHBvc1kgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgcG9zWCA9IHRhcmdldC5wb3NpdGlvbnMubGVmdCArIGUuZGVsdGFYO1xuICAgICAgaWYgKHBvc1ggPj0gMCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLmxlZnQgPSAwO1xuICAgICAgICB0YXJnZXQubm9kZS5zdHlsZS5sZWZ0ID0gMCArICdweCc7XG4gICAgICAgIC8vIGNoYW5nZSBkcmFnZ2luZyB0YXJnZXRcbiAgICAgICAgdGhpcy5kcmFnZ2luZ0luZm8gPSB0aGlzLl9nZXREcmFnZ2luZ0luZm8odGhpcy5ldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdSZWYgPSB0aGlzLmRyYWdnaW5nSW5mby5kcmFnZ2FibGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NYIDw9IC1jbGllbnRXaWR0aCkge1xuICAgICAgICB0YXJnZXQucG9zaXRpb25zLmxlZnQgPSAtY2xpZW50V2lkdGg7XG4gICAgICAgIHRhcmdldC5ub2RlLnN0eWxlLmxlZnQgPSAtY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgICAvLyBjaGFuZ2UgZHJhZ2dpbmcgdGFyZ2V0XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nUmVmID0gdGhpcy5kcmFnZ2luZ0luZm8uZHJhZ2dhYmxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9ucy5sZWZ0ID0gcG9zWDtcbiAgICAgIGdzYXAuc2V0KHRhcmdldC5ub2RlLCB7IGxlZnQ6IHBvc1ggfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEaWZmZXJlbnRFdmVudCkge1xuICAgICAgY29uc3QgZHJhZ2dpbmdJbmZvID0gdGhpcy5fZ2V0RHJhZ2dpbmdJbmZvKHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgICAgaWYgKGRyYWdnaW5nSW5mbykgdGhpcy5kcmFnZ2luZ0luZm8gPSBkcmFnZ2luZ0luZm87XG4gICAgfVxuICAgIHRoaXMuc3RhY2tNb3ZlRnJvbVRvID0gdGhpcy5fZ2V0U3RhY2tNb3ZlRnJvbVRvKCk7XG4gICAgdGhpcy5vcHRpb25zLmRyYWdNb3ZlKHRoaXMpO1xuICAgIC8vIHRvcCDsnZgg6rK97Jqw7IucXG4gICAgLy8gc2libGluZ0luZGV4IDAsIHBvc1kgMCwgLTEsIC0yLCAuLi4gLT4gZW5kIEV2ZW50IOyLnCAtNjY3XG4gICAgLy8gc2libGluZ0luZGV4IDAg6rCS7J2AIOygkOygkCBoaWRlLCBzbGlibGluZ2luZGV4IDHqsJLsnYAg7ZWY64uoIOu2gO2EsCDsoJDsoJAg64W47LacXG4gIH1cbiAgX2dldFN0YWNrTW92ZUZyb21UbygpIHtcbiAgICBjb25zdCB7IGZyb20sIHRvLCBjaGFuZ2VhYmxlVG8gfSA9IHRoaXMuZHJhZ2dpbmdJbmZvO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZyb20sXG4gICAgfTtcbiAgICBpZiAodG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdG9QYXJlbnQgPSB0aGlzLnN0YWNrc1t0b10uaW5uZXJQYXJlbnQ7XG4gICAgICByZXN1bHQudG8gPSB0bztcbiAgICAgIHJlc3VsdC50b1BhcmVudCA9IHRvUGFyZW50O1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlYWJsZVRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRvUGFyZW50ID0gdGhpcy5zdGFja3NbY2hhbmdlYWJsZVRvXS5pbm5lclBhcmVudDtcbiAgICAgIHJlc3VsdC50byA9IHRvUGFyZW50Lmxhc3RTZWVuSW5kZXggPyB0b1BhcmVudC5sYXN0U2VlbkluZGV4IDogY2hhbmdlYWJsZVRvO1xuICAgICAgcmVzdWx0LnRvUGFyZW50ID0gdG9QYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfYWRkRXZlbnRzKCkge1xuICAgIC8vIG1vYmlsZSDsnbwg6rK97JqwXG4gICAgLy8gdG91Y2hzdGFydCwgdG91Y2htb3ZlLCB0b3VjaGVuZCAz6rCA7KeAIOuTseuhnVxuXG4gICAgLy8gcGMg7J28IOqyveyasFxuICAgIC8vIERPTU1vdXNlU2Nyb2xsIG1vdXNld2hlZWxcbiAgICAvLyBtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cFxuICAgIC8vIGtleWRvd25cblxuICAgIC8vIHJlc2l6ZUNvbXBsZXRlIOyLnCBjdXJyZW50SWR4IOuhnCDsnbTrj5lcblxuICAgIGNvbnN0IG1jID0gbmV3IEhhbW1lcih0aGlzLmNvbnRhaW5lclJlZik7XG4gICAgLy8gc2F2ZSBtYyBpbnN0YW5jZSBmb3IgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyAtIG1jLm9mZigpO1xuICAgIHRoaXMuaGFtbWVycy5wdXNoKG1jKTtcbiAgICBtYy5hZGQoXG4gICAgICBuZXcgSGFtbWVyLlBhbih7XG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTEwsXG4gICAgICAgIHRocmVzaG9sZDogdGhpcy5vcHRpb25zLnRocmVzaG9sZFxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gSGFtbWVyIHBhbiBldmVudCBpc3N1ZSA6IG5vdCBzdXBwb3J0IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICB0aGlzLnN0YWNrcy5mb3JFYWNoKCh7IG5vZGUgfSkgPT4ge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcGFuc3RhcnQuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgbWMub24oJ3BhbmVuZCcsIHRoaXMuX3BhbmVuZC5iaW5kKHRoaXMpKTtcbiAgICBtYy5vbigncGFubGVmdCcsIHRoaXMuX3BhbmxlZnQuYmluZCh0aGlzKSk7XG4gICAgbWMub24oJ3BhbnJpZ2h0JywgdGhpcy5fcGFucmlnaHQuYmluZCh0aGlzKSk7XG4gICAgbWMub24oJ3BhbmRvd24nLCB0aGlzLl9wYW5kb3duLmJpbmQodGhpcykpO1xuICAgIG1jLm9uKCdwYW51cCcsIHRoaXMuX3BhbnVwLmJpbmQodGhpcykpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMucm90YXRpb25DYWxsYmFjayk7XG4gIH1cbiAgX3JvdGF0aW9uQ2FsbGJhY2soKSB7XG4gICAgY29uc29sZS5sb2coJ29yaWVudGF0aW9uY2hhbmdlJyk7XG4gICAgdGhpcy50aW1lciAmJiBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIGxldCBtYXggPSAwO1xuICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IEZ1bGxwYWdlU3dpcGVyLmdldFZpZXdwb3J0KCk7XG4gICAgICBpZiAodGhpcy52aWV3cG9ydC5jbGllbnRIZWlnaHQgIT09IHZpZXdwb3J0LmNsaWVudEhlaWdodCkge1xuICAgICAgICB0aGlzLnRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZXNpemVDYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1heCA+PSAxMCkge1xuICAgICAgICAgIHRoaXMudGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBtYXgrKztcbiAgICAgIH1cbiAgICB9LCA2MCk7XG4gIH1cbiAgX3Jlc2l6ZUNhbGxiYWNrKGUpIHtcbiAgICB0aGlzLnNldENvbW1vbkxheW91dCgpO1xuICAgIHRoaXMuc2V0TGF5b3V0KCk7XG4gICAgICAgIC8vIFBvc2l0aW9ucyB1cGRhdGVcbiAgICBjb25zdCByb290ID0gdGhpcy5wYXJlbnRzWzBdO1xuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9ucyhyb290KTtcbiAgICByb290LmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbnMoY2hpbGQpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhY2tzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9ucyhzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9ucyhzLmlubmVyUGFyZW50KTtcbiAgICB9KTtcbiAgICBcbiAgfVxuICBfdXBkYXRlUG9zaXRpb25zKHsgcG9zaXRpb25zLCBub2RlIH0pIHtcbiAgICBjb25zdCB7IGNsaWVudEhlaWdodCwgY2xpZW50V2lkdGggfSA9IHRoaXMudmlld3BvcnQ7XG4gICAgY29uc3QgeyB5UmVzaXplLCB0b3BSZXNpemUsIHhSZXNpemUsIGxlZnRSZXNpemUgfSA9IHBvc2l0aW9ucztcbiAgICBpZiAoeVJlc2l6ZSkge1xuICAgICAgcG9zaXRpb25zLnkgPSB5UmVzaXplICogY2xpZW50SGVpZ2h0O1xuICAgICAgZ3NhcC5zZXQobm9kZSwgeyB5OiBwb3NpdGlvbnMueSB9KTtcbiAgICB9XG4gICAgaWYgKHRvcFJlc2l6ZSkge1xuICAgICAgcG9zaXRpb25zLnRvcCA9IHRvcFJlc2l6ZSAqIGNsaWVudEhlaWdodDtcbiAgICAgIGdzYXAuc2V0KG5vZGUsIHsgdG9wOiBwb3NpdGlvbnMudG9wIH0pO1xuICAgIH1cbiAgICBpZiAoeFJlc2l6ZSkge1xuICAgICAgcG9zaXRpb25zLnggPSB4UmVzaXplICogY2xpZW50V2lkdGg7XG4gICAgICBnc2FwLnNldChub2RlLCB7IHg6IHBvc2l0aW9ucy54IH0pO1xuICAgIH1cbiAgICBpZiAobGVmdFJlc2l6ZSkge1xuICAgICAgcG9zaXRpb25zLmxlZnQgPSBsZWZ0UmVzaXplICogY2xpZW50V2lkdGg7XG4gICAgICBnc2FwLnNldChub2RlLCB7IGxlZnQ6IHBvc2l0aW9ucy5sZWZ0IH0pO1xuICAgIH1cbiAgfVxuICBzZXRDb21tb25MYXlvdXQoKSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IEZ1bGxwYWdlU3dpcGVyLmdldFZpZXdwb3J0KCk7XG4gICAgLy8gQmxvY2sgeCx5IHNjcm9sbGluZ1xuICAgIC8vIFJlcXVpcmVkIGluIFNhbXN1bmcgSW50ZXJuZXQgYnJvd3NlclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIH1cbiAgc2V0TGF5b3V0KCkge1xuICAgIC8vIOu2gOuqqCDsu6jthYzsnbTrhIggbGF5b3V0XG4gICAgdGhpcy5wYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgIC8vIGRhdGEtc3RhY2stdHlwZSDsl5Ag65Sw6528IGxheW91dCBzZXR0aW5nXG4gICAgICAvLyB4LCB5LCB0b3AsIGxlZnRcbiAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICB0aGlzLl9sYXlvdXRYKHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgJ3knOlxuICAgICAgICB0aGlzLl9sYXlvdXRZKHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5fbGF5b3V0Rml4ZWQocGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9sYXlvdXRYKHBhcmVudCkge1xuICAgIGNvbnN0IHsgY2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aCB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCB7IG5vZGUsIGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbm9kZS54ID0gbm9kZS55ID0gMDtcbiAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIG5vZGUuc3R5bGUud2lkdGggPSBjbGllbnRXaWR0aCAqIGNoaWxkcmVuLmxlbmd0aCArICdweCc7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKHsgbm9kZSB9KSA9PiB7XG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBjbGllbnRIZWlnaHQgKyAncHgnO1xuICAgIH0pO1xuICB9XG4gIF9sYXlvdXRZKHBhcmVudCkge1xuICAgIGNvbnN0IHsgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnZpZXdwb3J0O1xuICAgIGNvbnN0IHsgbm9kZSwgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBub2RlLnggPSBub2RlLnkgPSAwO1xuICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9IGNsaWVudEhlaWdodCAqIGNoaWxkcmVuLmxlbmd0aCArICdweCc7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKHsgbm9kZSB9KSA9PiB7XG4gICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGNsaWVudEhlaWdodCArICdweCc7XG4gICAgfSk7XG4gIH1cbiAgX2xheW91dEZpeGVkKHBhcmVudCkge1xuICAgIGNvbnN0IHsgY2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aCB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCB7IG5vZGUsIGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gY2xpZW50SGVpZ2h0ICsgJ3B4JztcbiAgICBub2RlLnN0eWxlLndpZHRoID0gY2xpZW50V2lkdGggKyAncHgnO1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoeyBub2RlIH0sIGlkeCwgYXJyKSA9PiB7XG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gMDtcbiAgICAgIG5vZGUuc3R5bGUubGVmdCA9IDA7XG4gICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGNsaWVudEhlaWdodCArICdweCc7XG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gY2xpZW50V2lkdGggKyAncHgnO1xuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSAoYXJyLmxlbmd0aCAtIGlkeCkgKiAxMDtcbiAgICB9KTtcbiAgfVxuICBzZXRQYXJlbnRzKCkge1xuICAgIHRoaXMucGFyZW50cyA9IEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdGFjay10eXBlXScpXG4gICAgKS5tYXAocGFyZW50ID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrLXR5cGUnKTtcbiAgICAgIGNvbnN0IGF4aXMgPVxuICAgICAgICB0eXBlID09PSAndG9wJyB8fCB0eXBlID09PSAneScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuXG4gICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgIC8vIGlmIHBhcmVudCBpcyByb290IHBhcmVudFxuICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcy5jb250YWluZXJSZWYpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBBcnJheVxuICAgICAgICAgIC5mcm9tKHBhcmVudC5jaGlsZHJlbilcbiAgICAgICAgICAuZmlsdGVyKGVsID0+IHR5cGVvZiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2snKSA9PT0gJ3N0cmluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBBcnJheVxuICAgICAgICAgIC5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdGFja10nKSlcbiAgICAgICAgICAuZmlsdGVyKGVsID0+IHR5cGVvZiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2snKSA9PT0gJ3N0cmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBheGlzLFxuICAgICAgICBub2RlOiBwYXJlbnQsXG4gICAgICAgIGlzUm9vdDogcGFyZW50ID09PSB0aGlzLmNvbnRhaW5lclJlZixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHNldFN0YWNrcygpIHtcbiAgICAvLyBmaWx0ZXIgZnVuY3Rpb24gLSBvbmx5IFtkYXRhLXN0YWNrXSBlbGVtZW50XG4gICAgY29uc3QgZmlsdGVyID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBpc1N0YWNrID1cbiAgICAgICAgbm9kZSAmJiB0eXBlb2Ygbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2snKSA9PT0gJ3N0cmluZyc7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGlzU3RhY2tcbiAgICAgICAgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFRcbiAgICAgICAgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgdGhpcy5jb250YWluZXJSZWYsXG4gICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcbiAgICAgIGZpbHRlcixcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIC8vIG5vZGUgaXMgW2RhdGEtc3RhY2tdIGVsZW1lbnRcbiAgICBsZXQgbm9kZSA9IHdhbGtlci5maXJzdENoaWxkKCk7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgbGV0IHR5cGU7XG4gICAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gcGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhY2stdHlwZScpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IHR5cGUgPT09ICd0b3AnIHx8IHR5cGUgPT09ICd5JztcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlzVmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgY29uc3QgaW5uZXJQYXJlbnRJbmRleCA9IHRoaXMucGFyZW50cy5maW5kSW5kZXgocCA9PiBwLm5vZGUgPT09IHBhcmVudE5vZGUpO1xuICAgICAgY29uc3QgaW5uZXJQYXJlbnQgPSB0aGlzLnBhcmVudHNbaW5uZXJQYXJlbnRJbmRleF07XG5cbiAgICAgIGlmIChpbm5lclBhcmVudC5ub2RlID09PSB0aGlzLmNvbnRhaW5lclJlZikge1xuICAgICAgICBpbm5lclBhcmVudC5vdXRlclBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkYXRhLXN0YWNrICh0aGlzIGlzIG91dGVyUGFyZW50KSA+IGRhdGEtc3RhY2stdHlwZSAodGhpcyBpcyBpbm5lclBhcmVudClcbiAgICAgICAgY29uc3Qgb3V0ZXJQYXJlbnQgPSB0aGlzLnBhcmVudHNbMF0uY2hpbGRyZW4uZmluZChvdXRlciA9PiB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyLm5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtc3RhY2stdHlwZV0nKSA9PT0gcGFyZW50Tm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXRlclBhcmVudCkge1xuICAgICAgICAgIGlubmVyUGFyZW50Lm91dGVyUGFyZW50ID0gb3V0ZXJQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2libGluZ0luZGV4ID0gaW5uZXJQYXJlbnQuY2hpbGRyZW4uZmluZEluZGV4KGVsID0+IGVsID09PSBub2RlKTtcbiAgICAgIGNvbnN0IHN0YWNrVmlldyA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgYXhpczogZGlyZWN0aW9uLFxuICAgICAgICBub2RlLCAvLyBmb3IgZS50YXJnZXRcbiAgICAgICAgaW5uZXJQYXJlbnQsXG4gICAgICAgIGlubmVyUGFyZW50SW5kZXgsXG4gICAgICAgIGlzUm9vdExldmVsU3RhY2s6IGlubmVyUGFyZW50LmlzUm9vdCxcbiAgICAgICAgY2hpbGRyZW46IGlubmVyUGFyZW50LmNoaWxkcmVuLFxuICAgICAgICBpc0ZpcnN0Tm9kZTogc2libGluZ0luZGV4ID09PSAwLFxuICAgICAgICBpc0xhc3ROb2RlOiBzaWJsaW5nSW5kZXggPT09IGlubmVyUGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEsXG4gICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9LFxuICAgICAgICBzaWJsaW5nSW5kZXgsXG4gICAgICB9O1xuICAgICAgaW5uZXJQYXJlbnQuY2hpbGRyZW5bc2libGluZ0luZGV4XSA9IHN0YWNrVmlldztcblxuICAgICAgY29uc3QgY2hpbGQgPSB3YWxrZXIuZmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAod2Fsa2VyLnBhcmVudE5vZGUoKSkge1xuICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0U2libGluZygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc3RhY2tWaWV3LmlzUm9vdExldmVsU3RhY2spIHtcbiAgICAgICAgc3RhY2tWaWV3LnN0YWNrSW5kZXggPSBpZHgrKztcbiAgICAgICAgc3RhY2tWaWV3LmNhbk1vdmVUb1NpYmxpbmcgPSB0aGlzLl9jYW5Nb3ZlVG9TaWJsaW5nKHN0YWNrVmlldyk7XG4gICAgICAgIHRoaXMuc3RhY2tzLnB1c2goc3RhY2tWaWV3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmNhbk1vdmVUb1BhcmVudCA9IHRoaXMuX2Nhbk1vdmVUb1BhcmVudChpdGVtKTtcbiAgICB9KTtcbiAgfVxuICBfY2FuTW92ZVRvUGFyZW50KHN0YWNrKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMucGFyZW50c1swXS5heGlzO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnBhcmVudHNbMF0udHlwZTtcblxuICAgIGNvbnN0IHsgY2FuTW92ZVRvU2libGluZywgaW5uZXJQYXJlbnQsIGlubmVyUGFyZW50SW5kZXggfSA9IHN0YWNrO1xuICAgIGNvbnN0IHsgb3V0ZXJQYXJlbnQgfSA9IGlubmVyUGFyZW50O1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHVwOiAhY2FuTW92ZVRvU2libGluZy51cCAmJiBheGlzID09PSAndmVydGljYWwnICYmICFvdXRlclBhcmVudC5pc0xhc3ROb2RlLFxuICAgICAgZG93bjogIWNhbk1vdmVUb1NpYmxpbmcuZG93biAmJiBheGlzID09PSAndmVydGljYWwnICYmICFvdXRlclBhcmVudC5pc0ZpcnN0Tm9kZSxcbiAgICAgIGxlZnQ6ICFjYW5Nb3ZlVG9TaWJsaW5nLmxlZnQgJiYgYXhpcyA9PT0gJ2hvcml6b250YWwnICYmICFvdXRlclBhcmVudC5pc0xhc3ROb2RlLFxuICAgICAgcmlnaHQ6ICFjYW5Nb3ZlVG9TaWJsaW5nLnJpZ2h0ICYmIGF4aXMgPT09ICdob3Jpem9udGFsJyAmJiAhb3V0ZXJQYXJlbnQuaXNGaXJzdE5vZGVcbiAgICB9O1xuXG4gICAgaWYgKHJlc3VsdC51cCkge1xuICAgICAgcmVzdWx0LnVwID0geyBcbiAgICAgICAgZnJvbTogc3RhY2suc3RhY2tJbmRleFxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlID09PSAneScpIHtcbiAgICAgICAgcmVzdWx0LnVwLmRyYWdnYWJsZSA9IG91dGVyUGFyZW50LmlubmVyUGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICd0b3AnKSB7XG4gICAgICAgIHJlc3VsdC51cC5kcmFnZ2FibGUgPSBvdXRlclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSB0aGlzLnBhcmVudHNbaW5uZXJQYXJlbnRJbmRleCArIDFdO1xuICAgICAgaWYgKG5leHRQYXJlbnQuYXhpcyA9PT0gYXhpcykge1xuICAgICAgICByZXN1bHQudXAudG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuWzBdLnN0YWNrSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQudXAuY2hhbmdlYWJsZVRvID0gbmV4dFBhcmVudC5jaGlsZHJlblswXS5zdGFja0luZGV4O1xuICAgICAgICAvLyDrj4TssKnsp4DqsIAg64uk66W4IOy2leyduCDqsr3smrBcbiAgICAgICAgLy8gLSB2ZXJ0aWNhbCAtPiBob3Jpem9udGFsXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVmdCkge1xuICAgICAgcmVzdWx0LmxlZnQgPSB7IFxuICAgICAgICBmcm9tOiBzdGFjay5zdGFja0luZGV4XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGUgPT09ICd4Jykge1xuICAgICAgICByZXN1bHQubGVmdC5kcmFnZ2FibGUgPSBvdXRlclBhcmVudC5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmVzdWx0LmxlZnQuZHJhZ2dhYmxlID0gb3V0ZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gdGhpcy5wYXJlbnRzW2lubmVyUGFyZW50SW5kZXggKyAxXTtcbiAgICAgIGlmIChuZXh0UGFyZW50LmF4aXMgPT09IGF4aXMpIHtcbiAgICAgICAgcmVzdWx0LmxlZnQudG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuWzBdLnN0YWNrSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDrj4TssKnsp4DqsIAg64uk66W4IOy2leyduCDqsr3smrBcbiAgICAgICAgLy8gLSBob3Jpem9udGFsIC0+IHZlcnRpY2FsXG4gICAgICAgIHJlc3VsdC5sZWZ0LmNoYW5nZWFibGVUbyA9IG5leHRQYXJlbnQuY2hpbGRyZW5bMF0uc3RhY2tJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmRvd24pIHtcbiAgICAgIHJlc3VsdC5kb3duID0geyBcbiAgICAgICAgZnJvbTogc3RhY2suc3RhY2tJbmRleFxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlID09PSAneScpIHtcbiAgICAgICAgcmVzdWx0LmRvd24uZHJhZ2dhYmxlID0gb3V0ZXJQYXJlbnQuaW5uZXJQYXJlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gdGhpcy5wYXJlbnRzW2lubmVyUGFyZW50SW5kZXggLSAxXTtcbiAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGUgPSBuZXh0UGFyZW50Lm91dGVyUGFyZW50O1xuICAgICAgICByZXN1bHQuZG93bi5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFBhcmVudC5heGlzID09PSBheGlzKSB7XG4gICAgICAgIHJlc3VsdC5kb3duLnRvID0gbmV4dFBhcmVudC5jaGlsZHJlbltuZXh0UGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN0YWNrSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDrj4TssKnsp4DqsIAg64uk66W4IOy2leyduCDqsr3smrBcbiAgICAgICAgLy8gLSBob3Jpem9udGFsIC0+IHZlcnRpY2FsXG4gICAgICAgIHJlc3VsdC5kb3duLmNoYW5nZWFibGVUbyA9IG5leHRQYXJlbnQuY2hpbGRyZW5bbmV4dFBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdGFja0luZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQucmlnaHQpIHtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHsgXG4gICAgICAgIGZyb206IHN0YWNrLnN0YWNrSW5kZXhcbiAgICAgIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHJlc3VsdC5yaWdodC5kcmFnZ2FibGUgPSBvdXRlclBhcmVudC5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSB0aGlzLnBhcmVudHNbaW5uZXJQYXJlbnRJbmRleCAtIDFdO1xuICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGUgPSBuZXh0UGFyZW50Lm91dGVyUGFyZW50O1xuICAgICAgICByZXN1bHQucmlnaHQuZHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRQYXJlbnQuYXhpcyA9PT0gYXhpcykge1xuICAgICAgICByZXN1bHQucmlnaHQudG8gPSBuZXh0UGFyZW50LmNoaWxkcmVuW25leHRQYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3RhY2tJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOuPhOywqeyngOqwgCDri6Trpbgg7LaV7J24IOqyveyasFxuICAgICAgICAvLyAtIHZlcnRpY2FsIC0+IGhvcml6b250YWxcbiAgICAgICAgcmVzdWx0LnJpZ2h0LmNoYW5nZWFibGVUbyBcbiAgICAgICAgICA9IG5leHRQYXJlbnQuY2hpbGRyZW5bbmV4dFBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdGFja0luZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX2Nhbk1vdmVUb1NpYmxpbmcoc3RhY2spIHtcbiAgICBjb25zdCBheGlzID0gc3RhY2suaW5uZXJQYXJlbnQuYXhpcztcbiAgICBjb25zdCB0eXBlID0gc3RhY2suaW5uZXJQYXJlbnQudHlwZTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB1cDogYXhpcyA9PT0gJ3ZlcnRpY2FsJyAmJiAhc3RhY2suaXNMYXN0Tm9kZSxcbiAgICAgIGRvd246IGF4aXMgPT09ICd2ZXJ0aWNhbCcgJiYgIXN0YWNrLmlzRmlyc3ROb2RlLFxuICAgICAgbGVmdDogYXhpcyA9PT0gJ2hvcml6b250YWwnICYmICFzdGFjay5pc0xhc3ROb2RlLFxuICAgICAgcmlnaHQ6IGF4aXMgPT09ICdob3Jpem9udGFsJyAmJiAhc3RhY2suaXNGaXJzdE5vZGUsXG4gICAgfTtcbiAgICBpZiAocmVzdWx0LnVwKSB7XG4gICAgICByZXN1bHQudXAgPSB7IFxuICAgICAgICBmcm9tOiBzdGFjay5zdGFja0luZGV4LCB0bzogc3RhY2suc3RhY2tJbmRleCArIDFcbiAgICAgIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIHJlc3VsdC51cC5kcmFnZ2FibGUgPSBzdGFjay5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAndG9wJykge1xuICAgICAgICByZXN1bHQudXAuZHJhZ2dhYmxlID0gc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVmdCkge1xuICAgICAgcmVzdWx0LmxlZnQgPSB7IGZyb206IHN0YWNrLnN0YWNrSW5kZXgsIHRvOiBzdGFjay5zdGFja0luZGV4ICsgMSB9O1xuICAgICAgaWYgKHR5cGUgPT09ICd4Jykge1xuICAgICAgICByZXN1bHQubGVmdC5kcmFnZ2FibGUgPSBzdGFjay5pbm5lclBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmVzdWx0LmxlZnQuZHJhZ2dhYmxlID0gc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5kb3duKSB7XG4gICAgICByZXN1bHQuZG93biA9IHsgZnJvbTogc3RhY2suc3RhY2tJbmRleCwgdG86IHN0YWNrLnN0YWNrSW5kZXggLSAxIH07XG4gICAgICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgICAgIHJlc3VsdC5kb3duLmRyYWdnYWJsZSA9IHN0YWNrLmlubmVyUGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICd0b3AnKSB7XG4gICAgICAgIHJlc3VsdC5kb3duLmRyYWdnYWJsZSA9IHRoaXMuc3RhY2tzW3N0YWNrLnN0YWNrSW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdC5yaWdodCkge1xuICAgICAgcmVzdWx0LnJpZ2h0ID0geyBmcm9tOiBzdGFjay5zdGFja0luZGV4LCB0bzogc3RhY2suc3RhY2tJbmRleCAtIDEgfTtcbiAgICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgICAgcmVzdWx0LnJpZ2h0LmRyYWdnYWJsZSA9IHN0YWNrLmlubmVyUGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICByZXN1bHQucmlnaHQuZHJhZ2dhYmxlID0gdGhpcy5zdGFja3Nbc3RhY2suc3RhY2tJbmRleCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gXG4gIGRlYnVnKCkge1xuICAgIHRoaXMuc3RhY2tzLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBGdWxscGFnZVN3aXBlci5nZXRSYW5kb21Db2xvcigpO1xuICAgICAgZWwubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKCdTVEFDS19QQVJFTlRTOiAnLCB0aGlzLnBhcmVudHMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coJ1NUQUNLX1ZJRVc6ICcsIHRoaXMuc3RhY2tzKTtcbiAgICB3aW5kb3cuZnBzID0gdGhpcztcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/index.js\n");

/***/ })

})